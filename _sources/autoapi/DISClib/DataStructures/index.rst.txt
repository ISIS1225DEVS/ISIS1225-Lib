:py:mod:`DISClib.DataStructures`
================================

.. py:module:: DISClib.DataStructures


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   adjcomponents/index.rst
   adjlist/index.rst
   adjmatrix/index.rst
   arraylist/index.rst
   binarysearchtree/index.rst
   bst/index.rst
   chaininghashtable/index.rst
   doublelinkedlist/index.rst
   heap/index.rst
   iminpqnode/index.rst
   indexheap/index.rst
   leftleaningrbtree/index.rst
   listnode/index.rst
   mapentry/index.rst
   node/index.rst
   probinghashtable/index.rst
   rbt/index.rst
   redblacktree/index.rst
   singlelinkedlist/index.rst
   treenode/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   DISClib.DataStructures.ArrayList
   DISClib.DataStructures.SingleLinked
   DISClib.DataStructures.DoubleLinked
   DISClib.DataStructures.SeparateChaining
   DISClib.DataStructures.LinearProbing




Attributes
~~~~~~~~~~

.. autoapisummary::

   DISClib.DataStructures.List
   DISClib.DataStructures.HashTable


.. py:class:: ArrayList


   Bases: :py:obj:`Generic`\ [\ :py:obj:`DISClib.Utils.default.T`\ ]

   **ArrayList** representa la estructura de datos para arreglos dinamicos (*ArrayList*), Implementada con Generic[T] y @dataclass para que sea una estructura de datos genérica.

   :param Generic: TAD (Tipo Abstracto de Datos) o ADT (Abstract Data Type) para una estructura de datos genéricas en python.
   :type Generic: T

   :returns: ADT de tipo *ArrayList* o Arreglo Dinámico.
   :rtype: ArrayList

   .. py:attribute:: iodata
      :type: Optional[List[DISClib.Utils.default.T]]

      Lista nativa de Python personalizable por el usuario para inicializar la estructura. Por defecto es *None* y el usuario puede incluirla como argumento al crear la estructura.

   .. py:attribute:: cmp_function
      :type: Optional[Callable[[DISClib.Utils.default.T, DISClib.Utils.default.T], int]]

      Función de comparación personalizable por el usuario para reconocer los elementos dentro del *ArrayList*. Por defecto es la función *lt_default_cmp_funcion()* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: elements
      :type: List[DISClib.Utils.default.T]

      Lista nativa de Python que contiene los elementos de la estructura.

   .. py:attribute:: key
      :type: Optional[str]

      Nombre de la llave personalizable por el usuario utilizada para reconocer los elementos dentro del *ArrayList*. Por defecto es la llave de diccionario (*dict*) *DEFAULT_DICT_KEY = 'id'* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: _size
      :type: int
      :value: 0

      Es el número de elementos que contiene la estructura, por defecto es 0 y se actualiza con cada operación que modifica la estructura.

   .. py:method:: __post_init__() -> None

      *__post_init__()* configura los parametros personalizados por el usuario al crear el *ArrayList*. En caso de no estar definidos, se asignan los valores por defecto, puede cargar listas nativas con el parametro *iodata* de python dentro de la estructura.



   .. py:method:: default_cmp_function(elm1, elm2) -> int

      *default_cmp_function()* es la función de comparación por defecto para comparar elementos dentro del *ArrayList*, es una función crucial para que la estructura funcione correctamente.

      :param elm1: primer elemento a comparar.
      :type elm1: Any
      :param elm2: segundo elemento a comparar.
      :type elm2: Any

      :returns: respuesta de la comparación entre los elementos, 0 si son iguales, 1 si elm1 es mayor que elm2, -1 si elm1 es menor.
      :rtype: int


   .. py:method:: _handle_error(err: Exception) -> None

      *_handle_error()* función propia de la estructura que maneja los errores que se pueden presentar en el *ArrayList*.

      Si se presenta un error en *ArrayList*, se formatea el error según el contexto (paquete/módulo/clase), la función (método) que lo generó y lo reenvia al componente superior en la jerarquía *DISCLib* para manejarlo segun se considere conveniente el usuario.

      :param err: Excepción que se generó en el *ArrayList*.
      :type err: Exception


   .. py:method:: _check_type(element: DISClib.Utils.default.T) -> bool

      *_check_type()* función propia de la estructura que revisa si el tipo de dato del elemento que se desea agregar al *ArrayList* es del mismo tipo contenido dentro de los elementos del *ArrayList*.

      :param element: elemento que se desea procesar en *ArrayList*.
      :type element: T

      :returns: operador que indica si el ADT *ArrayList* es del mismo tipo que el elemento que se desea procesar.
      :rtype: bool

      :raises TypeError: error si el tipo de dato del elemento que se desea agregar no es el mismo que el tipo de dato de los elementos que ya contiene el *ArrayList*.


   .. py:method:: is_empty() -> bool

      *is_empty()* revisa si el *ArrayList* está vacío.

      :returns: operador que indica si la estructura *ArrayList* está vacía.
      :rtype: bool


   .. py:method:: size() -> int

      *size()* devuelve el número de elementos que actualmente contiene el *ArrayList*.

      :returns: tamaño de la estructura *ArrayList*.
      :rtype: int


   .. py:method:: add_first(element: DISClib.Utils.default.T) -> None

      *add_first()* adiciona un elemento al inicio del *ArrayList*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: add_last(element: DISClib.Utils.default.T) -> None

      *add_last()* adiciona un elemento al final del *ArrayList*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: add_element(element: DISClib.Utils.default.T, pos: int) -> None

      *add_element()* adiciona un elemento en una posición especifica del *ArrayList*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T
      :param pos: posición en la que se desea agregar el elemento.
      :type pos: int

      :raises IndexError: error si la posición es inválida.
      :raises IndexError: error si la estructura está vacía.


   .. py:method:: get_first() -> DISClib.Utils.default.T

      *get_first()* lee el primer elemento del *ArrayList*.

      :raises Exception: error si la estructura está vacía.

      :returns: el primer elemento del *ArrayList*.
      :rtype: T


   .. py:method:: get_last() -> DISClib.Utils.default.T

      *get_last()* lee el último elemento del *ArrayList*.

      :raises Exception: error si la estructura está vacía.

      :returns: el ultimo elemento del *ArrayList*.
      :rtype: T


   .. py:method:: get_element(pos: int) -> DISClib.Utils.default.T

      *get_element()* lee un elemento en una posición especifica del *ArrayList*.

      :param pos: posición del elemento que se desea leer.
      :type pos: int

      :raises Exception: error si la estructura está vacía.
      :raises Exception: error si la posición es inválida.

      :returns: el elemento en la posición especifica del *ArrayList*.
      :rtype: T


   .. py:method:: remove_first() -> DISClib.Utils.default.T

      *remove_first()* elimina el primer elemento del *ArrayList*.

      :raises Exception: error si la estructura está vacía.

      :returns: el primer elemento eliminado del *ArrayList*.
      :rtype: T


   .. py:method:: remove_last() -> DISClib.Utils.default.T

      *remove_last()* elimina el último elemento del *ArrayList*.

      :raises Exception: error si la estructura está vacía.

      :returns: el ultimo elemento eliminado del *ArrayList*.
      :rtype: T


   .. py:method:: remove_element(pos: int) -> DISClib.Utils.default.T

      *remove_element()* elimina un elemento en una posición especifica del *ArrayList*.

      :param pos: posición del elemento que se desea eliminar.
      :type pos: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición es inválida.

      :returns: el elemento eliminado del *ArrayList*.
      :rtype: T


   .. py:method:: compare_elements(elem1: DISClib.Utils.default.T, elem2: DISClib.Utils.default.T) -> int

      *compare_elements()* compara dos elementos dentro del *ArrayList* según la función de comparación de la estructura.

      :param elem1: Primer elemento a comparar.
      :type elem1: T
      :param elem2: Segundo elemento a comparar.
      :type elem2: T

      :raises TypeError: error si la función de comparación no está definida.

      :returns: -1 si elem1 es menor que elem2, 0 si son iguales, 1 si elem1 es mayor que elem2.
      :rtype: int


   .. py:method:: find(element: DISClib.Utils.default.T) -> int

      *find()* busca el elemento dentro del *ArrayList* y devuelve su posición o -1 si no lo encuentra.

      :param element: elemento que se desea revisar en el *ArrayList*.
      :type element: T

      :returns: la posición del elemento en el *ArrayList*, -1 si no está.
      :rtype: int


   .. py:method:: change_info(new_info: DISClib.Utils.default.T, pos: int) -> None

      *change_info()* cambia la información de un elemento en la posición especificada del *ArrayList*.

      :param new_info: nueva información que se desea para el elemento.
      :type new_info: T
      :param pos: posición del elemento que se desea cambiar.
      :type pos: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición es inválida.


   .. py:method:: exchange(pos1: int, pos2: int) -> None

      *exchange()* intercambia la información de dos elementos en dos posiciones especificadas del *ArrayList*.

      :param pos1: posición del primer elemento.
      :type pos1: int
      :param pos2: posición del segundo elemento.
      :type pos2: int

      :raises Exception: error si la estructura está vacía.
      :raises Exception: error si la posición del primer elemento es inválida.
      :raises Exception: error si la posición del segundo elemento es inválida.


   .. py:method:: sublist(start: int, end: int) -> ArrayList[T]

      *sublist()* crea una sublista de la estructura según dos posiciones dentro del *ArrayList* original.

      :param start: posición inicial de la sublista.
      :type start: int
      :param end: posición final de la sublista.
      :type end: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición inicial o final son inválidas.

      :returns: una sublista de la estructura original con la función de comparación y la llave de la estructura original.
      :rtype: ArrayList[T]


   .. py:method:: concat(other: ArrayList[T]) -> ArrayList[T]

      *concat()* concatena dos estructuras de datos *ArrayList* para crear una estructura con los elementos de las dos estructuras.

      :param other: estructura de datos *ArrayList* que se desea concatenar con la estructura original.
      :type other: ArrayList[T]

      :raises TypeError: error si la estructura que se desea concatenar no es un *ArrayList*.
      :raises TypeError: error si la llave de la estructura que se desea unir no es la misma que la llave de la estructura original.
      :raises TypeError: error si la función de comparación de la estructura que se desea unir no es la misma que la función de comparación de la estructura original.

      :returns: Estructura de datos original *ArrayList* que contiene los elementos de las dos estructuras originales.
      :rtype: ArrayList[T]


   .. py:method:: __iter__()

      *__iter__()* iterador nativo de Python personalizado para el *ArrayList*. Permite utilizar los ciclos *for* de Python para recorrer los elementos de la estructura.

      :returns: iterador Python sobre los elementos del *ArrayList*.
      :rtype: __iter__


   .. py:method:: __len__() -> int

      *__len__()* función nativa de Python personalizada para el *ArrayList*. Permite utilizar la función *len()* de Python para recuperar el tamaño del *ArrayList*.

      :returns: tamaño del *ArrayList*.
      :rtype: int



.. py:class:: SingleLinked


   Bases: :py:obj:`Generic`\ [\ :py:obj:`DISClib.Utils.default.T`\ ]

   **SingleLinked** representa una estructura de datos dinámica de tipo lista sensillamente encadenada (*SingleLinked*), Implementada con Generic[T] y @dataclass para que sea una estructura de datos genérica.

   :param Generic: TAD (Tipo Abstracto de Datos) o ADT (Abstract Data Type) para una estructura de datos genéricas en python.
   :type Generic: T

   :returns: ADT de tipo *SingleLinked* o Lista Sensillamente Encadenada.
   :rtype: SingleLinked

   .. py:attribute:: iodata
      :type: Optional[List[DISClib.Utils.default.T]]

      Lista nativa de Python personalizable por el usuario para inicializar la estructura. Por defecto es *None* y el usuario puede incluirla como argumento al crear la estructura.

   .. py:attribute:: cmp_function
      :type: Optional[Callable[[DISClib.Utils.default.T, DISClib.Utils.default.T], int]]

      Función de comparación personalizable por el usuario para reconocer los elementos dentro del *SingleLinked*. Por defecto es la función *lt_default_cmp_funcion()* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: first
      :type: Optional[DISClib.DataStructures.listnode.SingleNode[DISClib.Utils.default.T]]

      Representa la referencia en memoria al primer nodo del *SingleLinked*.

   .. py:attribute:: last
      :type: Optional[DISClib.DataStructures.listnode.SingleNode[DISClib.Utils.default.T]]

      Representa la referencia en memoria al último nodo del *SingleLinked*.

   .. py:attribute:: key
      :type: Optional[str]

      Nombre de la llave personalizable por el usuario utilizada para reconocer los elementos dentro del *SingleLinked*. Por defecto es la llave de diccionario (*dict*)*DEFAULT_DICT_KEY = 'id'* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: _size
      :type: int
      :value: 0

      Es el número de elementos que contiene la estructura, por defecto es 0 y se actualiza con cada operación que modifica la estructura.

   .. py:method:: __post_init__() -> None

      *__post_init__()* configura los parametros personalizados por el usuario al crear el *SingleLinked*. En caso de no estar definidos, se asignan los valores por defecto, puede cargar listas nativas con el parametro *iodata* de python dentro de la estructura.



   .. py:method:: default_cmp_function(elm1, elm2) -> int

      *default_cmp_function()* es la función de comparación por defecto para comparar elementos dentro del *SingleLinked*, es una función crucial para que la estructura funcione correctamente.

      :param elm1: primer elemento a comparar.
      :type elm1: Any
      :param elm2: segundo elemento a comparar.
      :type elm2: Any

      :returns: respuesta de la comparación entre los elementos, 0 si son iguales, 1 si elm1 es mayor que elm2, -1 si elm1 es menor.
      :rtype: int


   .. py:method:: _handle_error(err: Exception) -> None

      *_handle_error()* función propia de la estructura que maneja los errores que se pueden presentar en el *SingleLinked*.

      Si se presenta un error en *SingleLinked*, se formatea el error según el contexto (paquete/módulo/clase), la función (método) que lo generó y lo reenvia al componente superior en la jerarquía *DISCLib* para manejarlo segun se considere conveniente el usuario.

      :param err: Excepción que se generó en el *SingleLinked*.
      :type err: Exception


   .. py:method:: _check_type(element: DISClib.Utils.default.T) -> bool

      *_check_type()* función propia de la estructura que revisa si el tipo de dato del elemento que se desea agregar al *SingleLinked* es del mismo tipo contenido dentro de los elementos del *SingleLinked*.

      :param element: elemento que se desea procesar en *SingleLinked*.
      :type element: T

      :raises TypeError: error si el tipo de dato del elemento que se desea agregar no es el mismo que el tipo de dato de los elementos que ya contiene el *SingleLinked*.

      :returns: operador que indica si el ADT *SingleLinked* es del mismo tipo que el elemento que se desea procesar.
      :rtype: bool


   .. py:method:: is_empty() -> bool

      *is_empty()* revisa si el *SingleLinked* está vacío.

      :returns: operador que indica si la estructura *SingleLinked* está vacía.
      :rtype: bool


   .. py:method:: size() -> int

      *size()* devuelve el número de elementos que actualmente contiene el *SingleLinked*.

      :returns: tamaño de la estructura *SingleLinked*.
      :rtype: int


   .. py:method:: add_first(element: DISClib.Utils.default.T) -> None

      *add_first()* adiciona un elemento al inicio del *SingleLinked*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: add_last(element: DISClib.Utils.default.T) -> None

      *add_last()* adiciona un elemento al final del *SingleLinked*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: add_element(element: DISClib.Utils.default.T, pos: int) -> None

      *add_element()* adiciona un elemento en una posición especifica del *SingleLinked*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T
      :param pos: posición en la que se desea agregar el elemento.
      :type pos: int

      :raises IndexError: error si la posición es inválida.
      :raises IndexError: error si la estructura está vacía.


   .. py:method:: get_first() -> Optional[DISClib.Utils.default.T]

      *get_first()* lee el primer elemento del *SingleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el primer elemento del *SingleLinked*.
      :rtype: Optional[T]


   .. py:method:: get_last() -> Optional[DISClib.Utils.default.T]

      *get_last()* lee el último elemento del *SingleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el ultimo elemento del *SingleLinked*.
      :rtype: Optional[T]


   .. py:method:: get_element(pos: int) -> Optional[DISClib.Utils.default.T]

      *get_element()* lee un elemento en una posición especifica del *SingleLinked*.

      :param pos: posición del elemento que se desea leer.
      :type pos: int

      :raises Exception: error si la estructura está vacía.
      :raises Exception: error si la posición es inválida.

      :returns: el elemento en la posición especifica del *SingleLinked*.
      :rtype: Optional[T]


   .. py:method:: remove_first() -> Optional[DISClib.Utils.default.T]

      *remove_first()* elimina el primer elemento del *SingleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el primer elemento eliminado del *SingleLinked*.
      :rtype: Optional[T]


   .. py:method:: remove_last() -> Optional[DISClib.Utils.default.T]

      *remove_last()* elimina el último elemento del *SingleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el ultimo elemento eliminado del *SingleLinked*.
      :rtype: Optional[T]


   .. py:method:: remove_element(pos: int) -> Optional[DISClib.Utils.default.T]

      *remove_element()* elimina un elemento en una posición especifica del *SingleLinked*.

      :param pos: posición del elemento que se desea eliminar.
      :type pos: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición es inválida.

      :returns: el elemento eliminado del *SingleLinked*.
      :rtype: Optional[T]


   .. py:method:: compare_elements(elem1: DISClib.Utils.default.T, elem2: DISClib.Utils.default.T) -> int

      *compare_elements()* compara dos elementos dentro del *SingleLinked* según la función de comparación de la estructura.

      :param elem1: Primer elemento a comparar.
      :type elem1: T
      :param elem2: Segundo elemento a comparar.
      :type elem2: T

      :raises TypeError: error si la función de comparación no está definida.

      :returns: -1 si elem1 es menor que elem2, 0 si son iguales, 1 si elem1 es mayor que elem2.
      :rtype: int


   .. py:method:: find(element: DISClib.Utils.default.T) -> int

      *find()* busca el elemento dentro del *SingleLinked* y devuelve su posición o -1 si no lo encuentra.

      :param element: elemento que se desea revisar en el *SingleLinked*.
      :type element: T

      :returns: la posición del elemento en el *SingleLinked*, -1 si no está.
      :rtype: int


   .. py:method:: change_info(new_info: DISClib.Utils.default.T, pos: int) -> None

      *change_info()* cambia la información de un elemento en la posición especificada del *SingleLinked*.

      :param new_info: nueva información que se desea para el elemento.
      :type new_info: T
      :param pos: posición del elemento que se desea cambiar.
      :type pos: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición es inválida.


   .. py:method:: exchange(pos1: int, pos2: int) -> None

      *exchange()* intercambia la información de dos elementos en dos posiciones especificadas del *SingleLinked*.

      :param pos1: posición del primer elemento.
      :type pos1: int
      :param pos2: posición del segundo elemento.
      :type pos2: int

      :raises Exception: error si la estructura está vacía.
      :raises Exception: error si la posición del primer elemento es inválida.
      :raises Exception: error si la posición del segundo elemento es inválida.


   .. py:method:: sublist(start: int, end: int) -> SingleLinked[T]

      *sublist()* crea una sublista de la estructura según dos posiciones dentro del *SingleLinked* original.

      :param start: posición inicial de la sublista.
      :type start: int
      :param end: posición final de la sublista.
      :type end: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición inicial o final son inválidas.

      :returns: una sublista de la estructura original con la función de comparación y la llave de la estructura original.
      :rtype: SingleLinked[T]


   .. py:method:: concat(other: SingleLinked[T]) -> SingleLinked[T]

      *concat()* concatena dos estructuras de datos *SingleLinked* para crear una estructura con los elementos de las dos estructuras.

      :param other: estructura de datos *SingleLinked* que se desea concatenar con la estructura original.
      :type other: SingleLinked[T]

      :raises TypeError: error si la estructura que se desea concatenar no es un *SingleLinked*.
      :raises TypeError: error si la llave de la estructura que se desea unir no es la misma que la llave de la estructura original.
      :raises TypeError: error si la función de comparación de la estructura que se desea unir no es la misma que la función de comparación de la estructura original.

      :returns: Estructura de datos original *SingleLinked* que contiene los elementos de las dos estructuras originales.
      :rtype: SingleLinked[T]


   .. py:method:: __iter__()

      *__iter__()* iterador nativo de Python personalizado para el *SingleLinked*. Permite utilizar los ciclos *for* de Python para recorrer los elementos de la estructura.

      :returns: iterador Python sobre los elementos del *SingleLinked*.
      :rtype: __iter__


   .. py:method:: __len__() -> int

      *__len__()* función nativa de Python personalizada para el *SingleLinked*. Permite utilizar la función *len()* de Python para recuperar el tamaño del *SingleLinked*.

      :returns: tamaño del *SingleLinked*.
      :rtype: int



.. py:class:: DoubleLinked


   Bases: :py:obj:`Generic`\ [\ :py:obj:`DISClib.Utils.default.T`\ ]

   **DoubleLinked** representa una estructura de datos para una lista doblemente enlazada/encadenada (*DoubleLinked*). Implementada con Generic[T] y @dataclass para que sea una estructura de datos genérica.

   :param Generic: TAD (Tipo Abstracto de Datos) o ADT (Abstract Data Type) para una estructura de datos genéricas en python.
   :type Generic: T

   :returns: ADT de tipo *DoubleLinked* o Lista Doblemente Encadenada.
   :rtype: DoubleLinked

   .. py:attribute:: iodata
      :type: Optional[List[DISClib.Utils.default.T]]

      Lista nativa de Python personalizable por el usuario para inicializar la estructura. Por defecto es *None* y el usuario puede incluirla como argumento al crear la estructura.

   .. py:attribute:: cmp_function
      :type: Optional[Callable[[DISClib.Utils.default.T, DISClib.Utils.default.T], int]]

      Función de comparación personalizable por el usuario para reconocer los elementos dentro del *DoubleLinked*. Por defecto es la función *lt_default_cmp_funcion()* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: _header
      :type: Optional[DISClib.DataStructures.listnode.DoubleNode[DISClib.Utils.default.T]]

      Representa el nodo sentinela de la cabecera de la estructura (header), por defecto es un *DoubleNode* vacío.

   .. py:attribute:: _trailer
      :type: Optional[DISClib.DataStructures.listnode.DoubleNode[DISClib.Utils.default.T]]

      Representa el nodo sentinela del colero de la estructura (trailer), por defecto es un *DoubleNode* vacío.

   .. py:attribute:: key
      :type: Optional[str]

      Nombre de la llave personalizable por el usuario utilizada para reconocer los elementos dentro del *DoubleLinked*. Por defecto es la llave de diccionario (*dict*) *DEFAULT_DICT_KEY = 'id'* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: _size
      :type: int

      Es el número de elementos que contiene la estructura, por defecto es 0, en algunos casos es -1 para ajustar por los nodos sentinelas de la estructura.

   .. py:method:: __post_init__() -> None

      *__post_init__()* configura los parametros personalizados por el usuario al crear el *DoubleLinked*. En caso de no estar definidos, se asignan los valores por defecto, puede cargar listas nativas con el parametro *iodata* de python dentro de la estructura.



   .. py:method:: default_cmp_function(elm1, elm2) -> int

      *default_cmp_function()* es la función de comparación por defecto para comparar elementos dentro del *DoubleLinked*, es una función crucial para que la estructura funcione correctamente.

      :param elm1: primer elemento a comparar.
      :type elm1: Any
      :param elm2: segundo elemento a comparar.
      :type elm2: Any

      :returns: respuesta de la comparación entre los elementos, 0 si son iguales, 1 si elm1 es mayor que elm2, -1 si elm1 es menor.
      :rtype: int


   .. py:method:: _handle_error(err: Exception) -> None

      *_handle_error()* función propia de la estructura que maneja los errores que se pueden presentar en el *DoubleLinked*.

      Si se presenta un error en *DoubleLinked*, se formatea el error según el contexto (paquete/módulo/clase), la función (método) que lo generó y lo reenvia al componente superior en la jerarquía *DISCLib* para manejarlo segun se considere conveniente el usuario.

      :param err: Excepción que se generó en el *DoubleLinked*.
      :type err: Exception


   .. py:method:: _check_type(element: DISClib.Utils.default.T) -> bool

      *_check_type()* función propia de la estructura que revisa si el tipo de dato del elemento que se desea agregar al *DoubleLinked* es del mismo tipo contenido dentro de los elementos del *DoubleLinked*.

      :param element: elemento que se desea procesar en *DoubleLinked*.
      :type element: T

      :raises TypeError: error si el tipo de dato del elemento que se desea agregar no es el mismo que el tipo de dato de los elementos que ya contiene el *DoubleLinked*.

      :returns: operador que indica si el ADT *DoubleLinked* es del mismo tipo que el elemento que se desea procesar.
      :rtype: bool


   .. py:method:: is_empty() -> bool

      *is_empty()* revisa si el *DoubleLinked* está vacío.

      :returns: operador que indica si la estructura *DoubleLinked* está vacía.
      :rtype: bool


   .. py:method:: size() -> int

      *size()* devuelve el número de elementos que actualmente contiene el *DoubleLinked*.

      :returns: tamaño de la estructura *DoubleLinked*.
      :rtype: int


   .. py:method:: add_first(element: DISClib.Utils.default.T) -> None

      *add_first()* adiciona un elemento al inicio del *DoubleLinked*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: add_last(element: DISClib.Utils.default.T) -> None

      *add_last()* adiciona un elemento al final del *DoubleLinked*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: add_element(element: DISClib.Utils.default.T, pos: int) -> None

      *add_element()* adiciona un elemento en una posición especifica del *DoubleLinked*.

      :param element: elemento que se desea agregar a la estructura.
      :type element: T
      :param pos: posición en la que se desea agregar el elemento.
      :type pos: int

      :raises IndexError: error si la posición es inválida.
      :raises IndexError: error si la estructura está vacía.


   .. py:method:: get_first() -> Optional[DISClib.Utils.default.T]

      *get_first()* lee el primer elemento del *DoubleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el primer elemento del *DoubleLinked*.
      :rtype: Optional[T]


   .. py:method:: get_last() -> Optional[DISClib.Utils.default.T]

      *get_last()* lee el último elemento del *DoubleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el ultimo elemento del *DoubleLinked*.
      :rtype: Optional[T]


   .. py:method:: get_element(pos: int) -> Optional[DISClib.Utils.default.T]

      *get_element()* lee un elemento en una posición especifica del *DoubleLinked*.

      :param pos: posición del elemento que se desea leer.
      :type pos: int

      :raises Exception: error si la estructura está vacía.
      :raises Exception: error si la posición es inválida.

      :returns: el elemento en la posición especifica del *DoubleLinked*.
      :rtype: Optional[T]


   .. py:method:: remove_first() -> Optional[DISClib.Utils.default.T]

      *remove_first()* elimina el primer elemento del *DoubleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el primer elemento eliminado del *DoubleLinked*.
      :rtype: Optional[T]


   .. py:method:: remove_last() -> Optional[DISClib.Utils.default.T]

      *remove_last()* elimina el último elemento del *DoubleLinked*.

      :raises Exception: error si la estructura está vacía.

      :returns: el ultimo elemento eliminado del *DoubleLinked*.
      :rtype: Optional[T]


   .. py:method:: remove_element(pos: int) -> Optional[DISClib.Utils.default.T]

      *remove_element()* elimina un elemento en una posición especifica del *DoubleLinked*.

      :param pos: posición del elemento que se desea eliminar.
      :type pos: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición es inválida.

      :returns: el elemento eliminado del *DoubleLinked*.
      :rtype: Optional[T]


   .. py:method:: compare_elements(elem1: DISClib.Utils.default.T, elem2: DISClib.Utils.default.T) -> int

      *compare_elements()* compara dos elementos dentro del *DoubleLinked* según la función de comparación de la estructura.

      :param elem1: Primer elemento a comparar.
      :type elem1: T
      :param elem2: Segundo elemento a comparar.
      :type elem2: T

      :raises TypeError: error si la función de comparación no está definida.

      :returns: -1 si elem1 es menor que elem2, 0 si son iguales, 1 si elem1 es mayor que elem2.
      :rtype: int


   .. py:method:: find(element: DISClib.Utils.default.T) -> int

      *find()* busca el elemento dentro del *DoubleLinked* y devuelve su posición o -1 si no lo encuentra.

      :param element: elemento que se desea revisar en el *DoubleLinked*.
      :type element: T

      :returns: la posición del elemento en el *DoubleLinked*, -1 si no está.
      :rtype: int


   .. py:method:: change_info(new_info: DISClib.Utils.default.T, pos: int) -> None

      *change_info()* cambia la información de un elemento en la posición especificada del *DoubleLinked*.

      :param new_info: nueva información que se desea para el elemento.
      :type new_info: T
      :param pos: posición del elemento que se desea cambiar.
      :type pos: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición es inválida.


   .. py:method:: exchange(pos1: int, pos2: int) -> None

      *exchange()* intercambia la información de dos elementos en dos posiciones especificadas del *DoubleLinked*.

      :param pos1: posición del primer elemento.
      :type pos1: int
      :param pos2: posición del segundo elemento.
      :type pos2: int

      :raises Exception: error si la estructura está vacía.
      :raises Exception: error si la posición del primer elemento es inválida.
      :raises Exception: error si la posición del segundo elemento es inválida.


   .. py:method:: sublist(start: int, end: int) -> DoubleLinked[T]

      *sublist()* crea una sublista de la estructura según dos posiciones dentro del *DoubleLinked* original.

      :param start: posición inicial de la sublista.
      :type start: int
      :param end: posición final de la sublista.
      :type end: int

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si la posición inicial o final son inválidas.

      :returns: una sublista de la estructura original con la función de comparación y la llave de la estructura original.
      :rtype: DoubleLinked[T]


   .. py:method:: concat(other: DoubleLinked[T]) -> DoubleLinked[T]

      *concat()* concatena dos estructuras de datos *DoubleLinked* para crear una estructura con los elementos de las dos estructuras.

      :param other: estructura de datos *DoubleLinked* que se desea concatenar con la estructura original.
      :type other: DoubleLinked[T]

      :raises TypeError: error si la estructura que se desea concatenar no es un *DoubleLinked*.
      :raises TypeError: error si la llave de la estructura que se desea unir no es la misma que la llave de la estructura original.
      :raises TypeError: error si la función de comparación de la estructura que se desea unir no es la misma que la función de comparación de la estructura original.

      :returns: Estructura de datos original *DoubleLinked* que contiene los elementos de las dos estructuras originales.
      :rtype: DoubleLinked[T]


   .. py:method:: __iter__()

      *__iter__()* iterador nativo de Python personalizado para el *DoubleLinked*. Permite utilizar los ciclos *for* de Python para recorrer los elementos de la estructura en orden ascendente.

      :returns: iterador Python sobre los elementos del *DoubleLinked*.
      :rtype: __iter__


   .. py:method:: __reversed__()

      *__reversed__* iterador nativo de Python personalizado para el *DoubleLinked*. Permite utilizar los ciclos *for* de Python para recorrer los elementos de la estructura en orden descendente.

      :Campos: *iterator* -- iterador Python sobre los elementos del *DoubleLinked*.


   .. py:method:: __len__() -> int

      *__len__()* función nativa de Python personalizada para el *DoubleLinked*. Permite utilizar la función *len()* de Python para recuperar el tamaño del *DoubleLinked*.

      :returns: tamaño del *DoubleLinked*.
      :rtype: int



.. py:class:: SeparateChaining


   Bases: :py:obj:`Generic`\ [\ :py:obj:`DISClib.Utils.default.T`\ ]

   **SeparateChaining** representa la estructura de datos de una tabla de hash con el método de encadenamiento por separación (*SeparateChaining*). En la estructura la información se almacena en registros (parejas llave-valor) donde la llave es única para cada valor y el valor puede ser cualquier tipo de dato. El indice es un *ArrayList* donde cada elemento es un *Bucket* que contiene los registros *MapEntry* que sufren colisiones en la tabla de hash.

   :param Generic: TAD (Tipo Abstracto de Datos) o ADT (Abstract Data Type) para una estructura de datos genéricas en python.
   :type Generic: T

   :returns: ADT de tipo *SeparateChaining* o tabla de hash con separación por encadenamiento.
   :rtype: SeparateChaining

   .. py:attribute:: iodata
      :type: Optional[List[DISClib.Utils.default.T]]

      Lista nativa de Python personalizable por el usuario para inicializar la estructura. Por defecto es *None* y el usuario puede incluirla como argumento al crear la estructura.

   .. py:attribute:: rehashable
      :type: bool
      :value: True

      Es el operador que indica si la tabla de hash se puede reconstruir utilizando el método de *rehash*, por defecto es 'True'.

   .. py:attribute:: nentries
      :type: int
      :value: 1

      espacio inicial reservado para la tabla de hash (n), por defecto es 1, pero debe configurarse según el número de entradas que se espera almacenar.

      *Nota*: el espacio reservado (n) no es la capacidad (M) de la tabla de hash.

   .. py:attribute:: mcapacity
      :type: int
      :value: 1

      Es la capacidad (M) con la que se inicializa la tabla de hash.

   .. py:attribute:: alpha
      :type: Optional[float]

      Es el factor de carga (*alpha*) con el que se inicializa la tabla de hash, por defecto es 4.0.

      *Nota*: alpha = n/M (n: número de entradas esperadas, M: capacidad de la tabla de hash).

   .. py:attribute:: cmp_function
      :type: Optional[Callable[[DISClib.Utils.default.T, DISClib.Utils.default.T], int]]

      Función de comparación personalizable por el usuario para reconocer los registros (pareja llave-valor) dentro del *SeparateChaining*. Por defecto es la función *lt_default_cmp_funcion()* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: hash_table
      :type: DISClib.DataStructures.arraylist.ArrayList[Bucket[DISClib.Utils.default.T]]

      Es el indice de la tabla Hash donde se almacenan los *Buckets*. Por defecto es un *ArrayList* vacío que se inicializa con la capacidad (M) configurada.

   .. py:attribute:: key
      :type: Optional[str]

      Nombre de la llave personalizable por el usuario utilizada para reconocer los registros (pareja llave-valor) dentro del *SeparateChaining*. Por defecto es la llave de diccionario (*dict*) *DEFAULT_DICT_KEY = 'id'* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: prime
      :type: Optional[int]

      Es el número entero primo (P) utilizado para calcular el hash para la llave de la tabla utilizando la función de compresión MAD. Por defecto es 109345121 definido en el parametro *DEFAULT_PRIME* propio de *DISClib*.

      *Nota:* la función MAD es: *h(k) = ((a*k + b) mod P) mod M*, donde *a* y *b* son números enteros aleatorios, *P* es un número primo y *M* es la capacidad de la tabla de hash.

   .. py:attribute:: _scale
      :type: Optional[int]
      :value: 0

      Es el número entero propio de la estructura utilizado como pendiente (a) en la función MAD para calcular el código hash de la llave.

   .. py:attribute:: _shift
      :type: Optional[int]
      :value: 0

      Es el número entero propio de la estructura utilizado como desplazamiento (b) de la función MAD para calcular el código hash de la llave.

   .. py:attribute:: _cur_alpha
      :type: Optional[float]
      :value: 0.0

      Es el factor de carga (*alpha*) actual de la tabla de hash.

   .. py:attribute:: min_alpha
      :type: Optional[float]

      Es el factor de carga (*alpha*) mínimo de la tabla de hash, por defecto es 2.0 definido en el parametro *MIN_CHAINING_ALPHA* propio de *DISClib*.

   .. py:attribute:: max_alpha
      :type: Optional[float]

      Es el factor de carga máximo de la tabla de hash, por defecto es 8.0 definido en el parametro *MAX_CHAINING_ALPHA* propio de *DISClib*.

   .. py:attribute:: _size
      :type: int
      :value: 0

      Es el número de entradas (n) que contiene la estructura, por defecto es 0 y se actualiza con cada operación que modifica la estructura.

   .. py:attribute:: _collisions
      :type: Optional[int]
      :value: 0

      Es el número entero para contar las colisiones en la estructura, por defecto es 0 y se actualiza con cada operación que modifica la estructura.

   .. py:attribute:: _key_type
      :type: Optional[type]

      Es el tipo de dato para las llaves de los registros (pareja llave-valor) que contiene la tabla de hash, por defecto es *None* y se configura al cargar la primer registro.

   .. py:attribute:: _value_type
      :type: Optional[type]

      Es el tipo de dato para los valores de los registros (pareja llave-valor) que contiene la tabla de hash, por defecto es *None* y se configura al cargar la primer registro.

   .. py:method:: __post_init__() -> None

      *__post_init__()* configura los parametros personalizados por el usuario al crear el *SeparateChaining*. En caso de no estar definidos, se asignan los valores por defecto, puede cargar listas nativas con el parametro *iodata* de python dentro de la estructura.



   .. py:method:: default_cmp_function(key1, entry2: DISClib.DataStructures.mapentry.MapEntry) -> int

      *default_cmp_function()* es la función de comparación por defecto para comparar la llave de un elemento vs. el registro (pareja llave-valor) o *MapEntry* que se desea agregar al *SeparateChaining*, es una función crucial para que la estructura funcione correctamente.

      :param key1: llave (*key*) del primer registro a comparar.
      :type key1: Any
      :param entry2: segundo registro (pareja llave-valor) a comparar.
      :type entry2: MapEntry

      :returns: respuesta de la comparación entre los elementos, 0 si las llaves (*key*) son iguales, 1 si key1 es mayor que la llave (*key*) de entry2, -1 si key1 es menor.
      :rtype: int


   .. py:method:: _handle_error(err: Exception) -> None

      *_handle_error()* función propia de la estructura que maneja los errores que se pueden presentar en el *SeparateChaining*.

      Si se presenta un error en *SeparateChaining*, se formatea el error según el contexto (paquete/módulo/clase), la función (método) que lo generó y lo reenvia al componente superior en la jerarquía *DISCLib* para manejarlo segun se considere conveniente el usuario.

      :param err: Excepción que se generó en el *SeparateChaining*.
      :type err: Exception


   .. py:method:: _check_type(entry: DISClib.DataStructures.mapentry.MapEntry) -> bool

      *_check_type()* función propia de la estructura que revisa si el tipo de dato del registro (pareja llave-valor) que se desea agregar al *SeparateChaining* es del mismo tipo contenido dentro de los *MapEntry* del *SeparateChaining*.

      :param element: elemento que se desea procesar en *SeparateChaining*.
      :type element: T

      :raises TypeError: error si el tipo de dato del elemento que se desea agregar no es el mismo que el tipo de dato de los elementos que ya contiene el *SeparateChaining*.

      :returns: operador que indica si el ADT *SeparateChaining* es del mismo tipo que el elemento que se desea procesar.
      :rtype: bool


   .. py:method:: is_empty() -> bool

      *is_empty()* revisa si el *SeparateChaining* está vacío.

      :returns: operador que indica si la estructura *SeparateChaining* está vacía.
      :rtype: bool


   .. py:method:: size() -> int

      *size()* devuelve el numero de entradas *MapEntry* que actualmente contiene el *SeparateChaining*.

      :returns: tamaño de la estructura *SeparateChaining*.
      :rtype: int


   .. py:method:: contains(key: DISClib.Utils.default.T) -> bool

      *contains()* responde si el *SeparateChaining* contiene un registro *MapEntry* con la llave *key*.

      :param key: llave del registro (pareja llave-valor) que se desea buscar en el *SeparateChaining*.
      :type key: T

      :raises IndexError: error si la estructura está vacía.

      :returns: operador que indica si el *SeparateChaining* contiene o no un registro con la llave *key*.
      :rtype: bool


   .. py:method:: put(key: DISClib.Utils.default.T, value: DISClib.Utils.default.T) -> None

      *put()* agrega un nuevo registro *MapEntry* al *SeparateChaining*, si la llave *key* ya existe en el *SeparateChaining* se reemplaza su valor *value*.

      :param key: llave asociada la nuevo *MapEntry*.
      :type key: T
      :param value: el valor asociado al nuevo *MapEntry*.
      :type value: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: get(key: DISClib.Utils.default.T) -> Optional[DISClib.DataStructures.mapentry.MapEntry]

      *get()* recupera el registro *MapEntry* cuya llave *key* sea ogial a la que se encuentre dentro del *SeparateChaining*, si no existe un registro con la llave, devuelve *None*.

      :param key: llave asociada al *MapEntry* que se desea buscar.
      :type key: T

      :raises IndexError: error si la estructura está vacía.

      :returns: *MapEntry* asociado a la llave *key* que se desea. *None* si no se encuentra.
      :rtype: Optional[MapEntry]


   .. py:method:: check_bucket(key: DISClib.Utils.default.T) -> Optional[Bucket]

      *check_bucket()* revisa el *Bucket* asociado a la llave *key* dentro del *SeparateChaining*. Recupera todo el *Bucket* asociado a la llave y si no existe, devuelve *None*.

      :param key: llave asociada al *Bucket* que se desea revisar
      :type key: T

      :raises IndexError: error si la estructura está vacía.

      :returns: *Bucket* asociado a la llave *key* que se desea. *None* si no se encuentra.
      :rtype: Optional[Bucket]


   .. py:method:: remove(key: DISClib.Utils.default.T) -> Optional[DISClib.DataStructures.mapentry.MapEntry]

      *remove()* elimina el registro *MapEntry* cuya llave *key* sea igual a la que se encuentre dentro del *SeparateChaining*, si no existe un registro con la llave, genera un error.

      :param key: llave asociada al *MapEntry* que se desea eliminar.
      :type key: T

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si el registro que se desea eliminar no existe dentro del *SeparateChaining*.

      :returns: registro *MapEntry* que se eliminó del *SeparateChaining*. *None* si no existe el registro asociada a la llave *key*.
      :rtype: Optional[MapEntry]


   .. py:method:: keys() -> DISClib.DataStructures.singlelinkedlist.SingleLinked[DISClib.Utils.default.T]

      *keys()* devuelve una lista (*SingleLinked*) con todas las llaves (*key*) de los registros (*MapEntry*) del *SeparateChaining*.

      :returns: lista (*SingleLinked*) con todas las llaves (*key*) del *SeparateChaining*.
      :rtype: SingleLinked[T]


   .. py:method:: values() -> DISClib.DataStructures.singlelinkedlist.SingleLinked[DISClib.Utils.default.T]

      *values()* devuelve una lista (*SingleLinked*) con todos los valores de los registros (*MapEntry*) del *SeparateChaining*.

      :returns: lista (*SingleLinked*) con todos los valores (*value*) del *SeparateChaining*.
      :rtype: SingleLinked[T]


   .. py:method:: entries() -> DISClib.DataStructures.singlelinkedlist.SingleLinked[DISClib.Utils.default.T]

      *entries()* devuelve una lista (*SingleLinked*) con tuplas de todas los registros (*MapEntry*) del *SeparateChaining*. Cada tupla contiene en la primera posición la llave (*key*) y en la segunda posición el valor (*value*) del registro.

      :returns: lista (*SingleLinked*) de tuplas con todas los registros del *SeparateChaining*.
      :rtype: SingleLinked[T]


   .. py:method:: rehash() -> None

      *rehash()* reconstruye la tabla de hash con una nueva capacidad (*M*) y un nuevo factor de carga (*alpha*) según los límites configurados por los parametros *max_alpha* y *min_alpha*.

      Si el factor de carga (*alpha*) es mayor que el límite superior (*max_alpha*), se duplica la capacidad (*M*) buscando el siguiente número primo (*P*) reconstruyendo la tabla.

      Si el factor de carga (*alpha) es menor que el límite inferior (*min_alpha*), se reduce a la mitad la capacidad (*M*) de la tabla buscando el siguiente número primo (*P*) reconstruyendo la tabla.


   .. py:method:: __len__() -> int

      *__len__()* función nativa de Python personalizada para el *SeparateChaining*. Permite utilizar la función *len()* de Python para recuperar el tamaño del *SeparateChaining*.

      :returns: tamaño del *SeparateChaining*.
      :rtype: int



.. py:class:: LinearProbing


   Bases: :py:obj:`Generic`\ [\ :py:obj:`DISClib.Utils.default.T`\ ]

   **LinearProbing** representa la estructura de datos de una tabla de hash con el método de encadenamiento por separación (*LinearProbing*). En la estructura la información se almacena en registros (parejas llave-valor) donde la llave es única para cada valor y el valor puede ser cualquier tipo de dato. El indice es un *ArrayList* donde cada elemento es un espacio (*slot*) de la tabla de hash, y cada espacio (*slot*) contiene un registro *MapEntry* (pareja llave-valor) o está vacío (None | EMPTY

   :param Generic: TAD (Tipo Abstracto de Datos) o ADT (Abstract Data Type) para una estructura de datos genéricas en python.
   :type Generic: T

   :returns: ADT de tipo *LinearProbing* o tabla de hash con separación por encadenamiento.
   :rtype: LinearProbing

   .. py:attribute:: iodata
      :type: Optional[List[DISClib.Utils.default.T]]

      Lista nativa de Python personalizable por el usuario para inicializar la estructura. Por defecto es *None* y el usuario puede incluirla como argumento al crear la estructura.

   .. py:attribute:: rehashable
      :type: bool
      :value: True

      Es el operador que indica si la tabla de hash se puede reconstruir utilizando el método de *rehash*, por defecto es 'True'.

   .. py:attribute:: nentries
      :type: int
      :value: 1

      espacio inicial reservado para la tabla de hash (n), por defecto es 1, pero debe configurarse según el número de entradas que se espera almacenar.

      *Nota*: el espacio reservado (n) no es la capacidad (M) de la tabla de hash.

   .. py:attribute:: mcapacity
      :type: int
      :value: 2

      Es la capacidad (M) con la que se inicializa la tabla de hash.

   .. py:attribute:: alpha
      :type: Optional[float]

      Es el factor de carga (*alpha*) con el que se inicializa la tabla de hash, por defecto es 0.50.

      *Nota*: alpha = n/M (n: número de entradas esperadas, M: capacidad de la tabla de hash).

   .. py:attribute:: cmp_function
      :type: Optional[Callable[[DISClib.Utils.default.T, DISClib.Utils.default.T], int]]

      Función de comparación personalizable por el usuario para reconocer los registros (pareja llave-valor) dentro del *LinearProbing*. Por defecto es la función *lt_default_cmp_funcion()* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: hash_table
      :type: DISClib.DataStructures.arraylist.ArrayList[DISClib.DataStructures.mapentry.MapEntry[DISClib.Utils.default.T]]

      Es el indice de la tabla Hash donde se almacenan los *Buckets*. Por defecto es un *ArrayList* vacío que se inicializa con la capacidad (M) configurada.

   .. py:attribute:: key
      :type: Optional[str]

      Nombre de la llave personalizable por el usuario utilizada para reconocer los registros (pareja llave-valor) dentro del *LinearProbing*. Por defecto es la llave de diccionario (*dict*) *DEFAULT_DICT_KEY = 'id'* propia de *DISClib*, puede ser un parametro al crear la estructura.

   .. py:attribute:: prime
      :type: Optional[int]

      Es el número entero primo (P) utilizado para calcular el hash para la llave de la tabla utilizando la función de compresión MAD. Por defecto es 109345121 definido en el parametro *DEFAULT_PRIME* propio de *DISClib*.

      *Nota:* la función MAD es: *h(k) = ((a*k + b) mod P) mod M*, donde *a* y *b* son números enteros aleatorios, *P* es un número primo y *M* es la capacidad de la tabla de hash.

   .. py:attribute:: _scale
      :type: Optional[int]
      :value: 0

      Es el número entero propio de la estructura utilizado como pendiente (a) en la función MAD para calcular el código hash de la llave.

   .. py:attribute:: _shift
      :type: Optional[int]
      :value: 0

      Es el número entero propio de la estructura utilizado como desplazamiento (b) de la función MAD para calcular el código hash de la llave.

   .. py:attribute:: _cur_alpha
      :type: Optional[float]
      :value: 0

      Es el factor de carga (*alpha*) actual de la tabla de hash.

   .. py:attribute:: min_alpha
      :type: Optional[float]

      Es el factor de carga (*alpha*) mínimo de la tabla de hash, por defecto es 0.20 definido en el parametro *MIN_PROBING_ALPHA* propio de *DISClib*.

   .. py:attribute:: max_alpha
      :type: Optional[float]

      Es el factor de carga máximo de la tabla de hash, por defecto es 0.80 definido en el parametro *MAX_PROBING_ALPHA* propio de *DISClib*.

   .. py:attribute:: _size
      :type: int
      :value: 0

      Es el número de entradas (n) que contiene la estructura, por defecto es 0 y se actualiza con cada operación que modifica la estructura.

   .. py:attribute:: _collisions
      :type: Optional[int]
      :value: 0

      Es el número entero para contar las colisiones en la estructura, por defecto es 0 y se actualiza con cada operación que modifica la estructura.

   .. py:attribute:: _key_type
      :type: Optional[type]

      Es el tipo de dato para las llaves de los registros (pareja llave-valor) que contiene la tabla de hash, por defecto es *None* y se configura al cargar la primer registro.

   .. py:attribute:: _value_type
      :type: Optional[type]

      Es el tipo de dato para los valores de los registros (pareja llave-valor) que contiene la tabla de hash, por defecto es *None* y se configura al cargar la primer registro.

   .. py:method:: __post_init__() -> None

      *__post_init__()* configura los parametros personalizados por el usuario al crear el *LinearProbing*. En caso de no estar definidos, se asignan los valores por defecto, puede cargar listas nativas con el parametro *iodata* de python dentro de la estructura.



   .. py:method:: default_cmp_function(key1, entry2: DISClib.DataStructures.mapentry.MapEntry) -> int

      *default_cmp_function()* es la función de comparación por defecto para comparar la llave de un elemento vs. el registro (pareja llave-valor) o *MapEntry* que se desea agregar al *LinearProbing*, es una función crucial para que la estructura funcione correctamente.

      :param key1: llave (*key*) de la primer registro a comparar.
      :type key1: Any
      :param entry2: segundo registro (pareja llave-valor) a comparar.
      :type entry2: MapEntry

      :returns: respuesta de la comparación entre los elementos, 0 si las llaves (*key*) son iguales, 1 si key1 es mayor que la llave (*key*) de entry2, -1 si key1 es menor.
      :rtype: int


   .. py:method:: _handle_error(err: Exception) -> None

      *_handle_error()* función propia de la estructura que maneja los errores que se pueden presentar en el *LinearProbing*.

      Si se presenta un error en *LinearProbing*, se formatea el error según el contexto (paquete/módulo/clase), la función (método) que lo generó y lo reenvia al componente superior en la jerarquía *DISCLib* para manejarlo segun se considere conveniente el usuario.

      :param err: Excepción que se generó en el *LinearProbing*.
      :type err: Exception


   .. py:method:: _check_type(entry: DISClib.DataStructures.mapentry.MapEntry) -> bool

      *_check_type()* función propia de la estructura que revisa si el tipo de dato del registro (pareja llave-valor) que se desea agregar al *LinearProbing* es del mismo tipo contenido dentro de los *MapEntry* del *LinearProbing*.

      :param element: elemento que se desea procesar en *LinearProbing*.
      :type element: T

      :raises TypeError: error si el tipo de dato del elemento que se desea agregar no es el mismo que el tipo de dato de los elementos que ya contiene el *LinearProbing*.

      :returns: operador que indica si el ADT *LinearProbing* es del mismo tipo que el elemento que se desea procesar.
      :rtype: bool


   .. py:method:: is_empty() -> bool

      *is_empty()* revisa si el *LinearProbing* está vacío.

      :returns: operador que indica si la estructura *LinearProbing* está vacía.
      :rtype: bool


   .. py:method:: size() -> int

      *size()* devuelve el numero de entradas *MapEntry* que actualmente contiene el *LinearProbing*.

      :returns: tamaño de la estructura *LinearProbing*.
      :rtype: int


   .. py:method:: contains(key: DISClib.Utils.default.T) -> bool

      *contains()* responde si el *LinearProbing* contiene un registro *MapEntry* con la llave *key*.

      :param key: llave del registro (pareja llave-valor) que se desea buscar en el *LinearProbing*.
      :type key: T

      :raises IndexError: error si la estructura está vacía.

      :returns: operador que indica si el *LinearProbing* contiene o no un registro con la llave *key*.
      :rtype: bool


   .. py:method:: put(key: DISClib.Utils.default.T, value: DISClib.Utils.default.T) -> None

      *put()* agrega una nuevo registro *MapEntry* al *LinearProbing*, si la llave *key* ya existe en el *LinearProbing* se reemplaza su valor *value*.

      :param key: llave asociada la nuevo *MapEntry*.
      :type key: T
      :param value: el valor asociado al nuevo *MapEntry*.
      :type value: T

      :raises Exception: si la operación no se puede realizar, se invoca la función *_handle_error()* para manejar el error.


   .. py:method:: get(key: DISClib.Utils.default.T) -> Optional[DISClib.DataStructures.mapentry.MapEntry]

      *get()* recupera el registro *MapEntry* cuya llave *key* sea ogial a la que se encuentre dentro del *LinearProbing*, si no existe un registro con la llave, devuelve *None*.

      :param key: llave asociada al *MapEntry* que se desea buscar.
      :type key: T

      :raises IndexError: error si la estructura está vacía.

      :returns: *MapEntry* asociado a la llave *key* que se desea. *None* si no se encuentra.
      :rtype: Optional[MapEntry]


   .. py:method:: check_slots(key: DISClib.Utils.default.T) -> Optional[DISClib.DataStructures.singlelinkedlist.SingleLinked[DISClib.DataStructures.mapentry.MapEntry]]

      *check_slots()* recupera la lista (*SingleLinked*) de registros (parejas llave-valor) asociadas a la llave *key* dentro del *LinearProbing*. Recupera los *MapEntry* con el mismo hash y si no existe, devuelve *None*.

      :param key: llave asociada a los *MapEntry* y *Slots* que se desean buscar.
      :type key: T

      :raises Exception: error si la estructura está vacía.

      :returns: lista sencillamente encadenada (*SingleLinked*) con todas los *MapEntry* asociados a la llave *key* dentro del *LinearProbing*.
      :rtype: Optional[SingleLinked[MapEntry]]


   .. py:method:: remove(key: DISClib.Utils.default.T) -> Optional[DISClib.Utils.default.T]

      *remove()* elimina el registro *MapEntry* cuya llave *key* sea igual a la que se encuentre dentro del *LinearProbing*, si no existe un registro con la llave, genera un error.

      :param key: llave asociada al *MapEntry* que se desea eliminar.
      :type key: T

      :raises IndexError: error si la estructura está vacía.
      :raises IndexError: error si el registro que se desea eliminar no existe dentro del *LinearProbing*.

      :returns: registro *MapEntry* que se eliminó del *LinearProbing*. *None* si no existe el registro asociada a la llave *key*.
      :rtype: Optional[MapEntry]


   .. py:method:: keys() -> DISClib.DataStructures.singlelinkedlist.SingleLinked[DISClib.Utils.default.T]

      *keys()* devuelve una lista (*SingleLinked*) con todas las llaves (*key*) de los registros (*MapEntry*) del *LinearProbing*.

      :returns: lista (*SingleLinked*) con todas las llaves (*key*) del *LinearProbing*.
      :rtype: SingleLinked[T]


   .. py:method:: values() -> DISClib.DataStructures.singlelinkedlist.SingleLinked[DISClib.Utils.default.T]

      *values()* devuelve una lista (*SingleLinked*) con todos los valores de los registros (*MapEntry*) del *LinearProbing*.

      :returns: lista (*SingleLinked*) con todos los valores (*value*) del *LinearProbing*.
      :rtype: SingleLinked[T]


   .. py:method:: entries() -> DISClib.DataStructures.singlelinkedlist.SingleLinked[DISClib.Utils.default.T]

      *entries()* devuelve una lista (*SingleLinked*) con tuplas de todas los registros (*MapEntry*) del *LinearProbing*. Cada tupla contiene en la primera posición la llave (*key*) y en la segunda posición el valor (*value*) del registro.

      :returns: lista (*SingleLinked*) de tuplas con todas los registros del *LinearProbing*.
      :rtype: SingleLinked[T]


   .. py:method:: _find_slot(hkey: int, key: DISClib.Utils.default.T) -> int

      *_find_slot()* encuentra el indice del registro *MapEtry* en el *LinearProbing*, si el registro no existe, devuelve el indice del primer registro disponible.

      :param hkey: indice del registro (pareja llave-valor) en el *LinearProbing*.
      :type hkey: int
      :param key: llave del registro (pareja llave-valor) que se desea buscar.
      :type key: T

      :returns: devuelve el indice negativo si encuentra espacio disponible (None | EMPTY) o si el registro no existe, devuelve el indice positivo si el registro existe.
      :rtype: int


   .. py:method:: _is_available(entry: DISClib.DataStructures.mapentry.MapEntry) -> bool

      *_is_available()* permite verificar si un registro *MapEntry* está disponible en el *LinearProbing*. Es decir si la llave es nula (None) o vacía (EMPTY).

      :param entry: registro (pareja llave-valor) que se desea verificar.
      :type entry: MapEntry

      :returns: operador que indica si el registro está disponible o no en el *LinearProbing*.
      :rtype: bool


   .. py:method:: rehash() -> None

      *rehash()* reconstruye la tabla de hash con una nueva capacidad (*M*) y un nuevo factor de carga (*alpha*) según los límites configurados por los parametros *max_alpha* y *min_alpha*.

      Si el factor de carga (*alpha*) es mayor que el límite superior (*max_alpha*), se duplica la capacidad (*M*) buscando el siguiente número primo (*P*) reconstruyendo la tabla.

      Si el factor de carga (*alpha) es menor que el límite inferior (*min_alpha*), se reduce a la mitad la capacidad (*M*) de la tabla buscando el siguiente número primo (*P*) reconstruyendo la tabla.


   .. py:method:: __len__() -> int

      *__len__()* función nativa de Python personalizada para el *LinearProbing*. Permite utilizar la función *len()* de Python para recuperar el tamaño del *LinearProbing*.

      :returns: tamaño del *LinearProbing*.
      :rtype: int



.. py:data:: List

   Lista de estructuras que se pueden ordenar por el algoritmo de ordenamiento (ADT *List* y sus estructuras especificas *ArrayList*, *LinkedList*, *DoubleLinkedList*, *Queue* y *Stack*)

.. py:data:: HashTable

   Lista de tipos de estructuras que pueden cambiar su mecánica de hashing (ADT *HashTable* y sus estructuras especificas *SeparateChaining* y *LinearProbing*)

