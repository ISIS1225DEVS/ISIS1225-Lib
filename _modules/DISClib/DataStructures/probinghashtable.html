<!DOCTYPE html>
<html class="writer-html5" lang="es" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DISClib.DataStructures.probinghashtable &mdash; documentación de DISClib - 0.0.1</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/fonts.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=6fcc102b"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../../_static/translations.js?v=efdbd0b9"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DISClib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Buscar documentos" aria-label="Buscar documentos" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">DISClib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../testmd.html">Example Markdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DISClib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Código de módulo</a></li>
          <li class="breadcrumb-item"><a href="../../DISClib.html">DISClib</a></li>
          <li class="breadcrumb-item"><a href="../DataStructures.html">DISClib.DataStructures</a></li>
      <li class="breadcrumb-item active">DISClib.DataStructures.probinghashtable</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Código fuente para DISClib.DataStructures.probinghashtable</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># -*- coding: utf-8 -*-</span>
<span class="sd"># TODO add docstring</span>

<span class="sd">*IMPORTANTE:* Este código y sus especificaciones para Python están basados en las implementaciones propuestas por los siguientes autores/libros:</span>

<span class="sd">    #. Algorithms, 4th Edition, Robert Sedgewick y Kevin Wayne.</span>
<span class="sd">    #. Data Structure and Algorithms in Python, M.T. Goodrich, R. Tamassia, M.H. Goldwasser.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># native python modules</span>
<span class="c1"># import dataclass to define the hash table</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="c1"># import modules for defining the entry type in the hash table</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Generic</span>
<span class="c1"># import inspect for getting the name of the current function</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="c1"># random module for the MAD compression function</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="c1"># custom modules</span>
<span class="c1"># generic error handling and type checking</span>
<span class="kn">from</span> <span class="nn">DISClib.DataStructures.mapentry</span> <span class="kn">import</span> <span class="n">MapEntry</span>
<span class="kn">from</span> <span class="nn">DISClib.DataStructures.arraylist</span> <span class="kn">import</span> <span class="n">ArrayList</span>
<span class="c1"># util functions for the hash table</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.numbers</span> <span class="kn">import</span> <span class="n">next_prime</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.numbers</span> <span class="kn">import</span> <span class="n">hash_compress</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.error</span> <span class="kn">import</span> <span class="n">error_handler</span>
<span class="c1"># default cmp function for the hash table</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">ht_default_cmp_funcion</span>
<span class="c1"># default data type for the hash table</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">T</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">VALID_DATA_TYPE_LT</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">DEFAULT_DICT_KEY</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">VALID_IO_TYPE</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">DEFAULT_PRIME</span>


<span class="c1"># checking custom modules</span>
<span class="k">assert</span> <span class="n">MapEntry</span>
<span class="k">assert</span> <span class="n">ArrayList</span>
<span class="k">assert</span> <span class="n">next_prime</span>
<span class="k">assert</span> <span class="n">hash_compress</span>
<span class="k">assert</span> <span class="n">error_handler</span>
<span class="k">assert</span> <span class="n">ht_default_cmp_funcion</span>
<span class="k">assert</span> <span class="n">T</span>
<span class="k">assert</span> <span class="n">VALID_DATA_TYPE_LT</span>
<span class="k">assert</span> <span class="n">DEFAULT_DICT_KEY</span>
<span class="k">assert</span> <span class="n">VALID_IO_TYPE</span>
<span class="k">assert</span> <span class="n">DEFAULT_PRIME</span>

<span class="c1"># default load factor for separating chaining</span>
<span class="c1"># :data: DEFAULT_PROBING_ALPHA</span>
<div class="viewcode-block" id="DEFAULT_PROBING_ALPHA">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.DEFAULT_PROBING_ALPHA">[documentos]</a>
<span class="n">DEFAULT_PROBING_ALPHA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor de carga (alpha) por defecto e ideal para el LinearProbing, por defecto es 0.5.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># :data: MAX_PROBING_ALPHA</span>
<div class="viewcode-block" id="MAX_PROBING_ALPHA">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.MAX_PROBING_ALPHA">[documentos]</a>
<span class="n">MAX_PROBING_ALPHA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor de carga (alpha) máximo para el LinearProbing, por defecto es 8.0.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># :data: MIN_PROBING_ALPHA</span>
<div class="viewcode-block" id="MIN_PROBING_ALPHA">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.MIN_PROBING_ALPHA">[documentos]</a>
<span class="n">MIN_PROBING_ALPHA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor de carga (alpha) mínimo para el LinearProbing, por defecto es 2.0.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># :data: EMPTY</span>
<div class="viewcode-block" id="EMPTY">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.EMPTY">[documentos]</a>
<span class="n">EMPTY</span> <span class="o">=</span> <span class="s2">&quot;__EMPTY__&quot;</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Constante que representa una entrada vacío en el LinearProbing, por defecto es &quot;__EMPTY__&quot;.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="nd">@dataclass</span>
<div class="viewcode-block" id="LinearProbing">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing">[documentos]</a>
<span class="k">class</span> <span class="nc">LinearProbing</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;*LinearProbing* Es una clase que representa una tabla de hash con el método de encadenamiento por de separación (Separate Chaining). Donde la llave es única para cada valor y el valor puede ser cualquier tipo de dato.</span>

<span class="sd">    Args:</span>
<span class="sd">        Generic (T): Tipo de dato genérico dentro del registro del mapa.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: error si la información del registro del mapa (llave o valor) no son del tipo adecuado.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LinearProbing: ADT de tipo LinearProbing o tabla de hash con separación por encadenamiento.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># input tuples from python list</span>
    <span class="c1"># :attr: iodata</span>
<div class="viewcode-block" id="LinearProbing.iodata">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.iodata">[documentos]</a>
    <span class="n">iodata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lista nativa de Python que contiene los elementos de entrada a la estructura, por defecto es None y el usuario puede incluir una lista nativa de python como argumento.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># reserved space for the hash table</span>
    <span class="c1"># :attr: nentries</span>
<div class="viewcode-block" id="LinearProbing.nentries">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.nentries">[documentos]</a>
    <span class="n">nentries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el espacio reservado para la tabla de hash (n), por defecto es 1, pero debe configurarse según el número de entradas que se espera almacenar.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># starting load factor (alpha) for the hash table</span>
    <span class="c1"># :attr: alpha</span>
<div class="viewcode-block" id="LinearProbing.alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.alpha">[documentos]</a>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_PROBING_ALPHA</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga (alpha) con el que se inicializa la tabla de hash, por defecto es 4.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prime number (P) for the MAD compression function</span>
    <span class="c1"># :attr: prime</span>
<div class="viewcode-block" id="LinearProbing.prime">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.prime">[documentos]</a>
    <span class="n">prime</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_PRIME</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número primo (P) utilizado para calcular el código hash de la llave con la función de compresión MAD, por defecto es 109345121.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># actual place to store the entries in the hash table</span>
    <span class="c1"># :attr: hash_table</span>
<div class="viewcode-block" id="LinearProbing.hash_table">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.hash_table">[documentos]</a>
    <span class="n">hash_table</span><span class="p">:</span> <span class="n">ArrayList</span><span class="p">[</span><span class="n">MapEntry</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">ArrayList</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el indice de la tabla de hash donde se almacenan los *MapEntry*, implementado con un *ArrayList* de DISCLib. en el *__post_init__()* se inicializa con la capacidad inicial de la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># boolean to indicate if the hash table can be rehashed</span>
    <span class="c1"># :attr: rehashable</span>
<div class="viewcode-block" id="LinearProbing.rehashable">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.rehashable">[documentos]</a>
    <span class="n">rehashable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es un booleano que indica si la tabla de hash se puede reconstruir utilizando el método de rehash, por defecto es True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># starting capacity (M|m) for the hash table</span>
    <span class="c1"># :attr: mcapacity</span>
<div class="viewcode-block" id="LinearProbing.mcapacity">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.mcapacity">[documentos]</a>
    <span class="n">mcapacity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es la capacidad (M) con la que se inicializa la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># actual number of used entries (n) in the hash table</span>
    <span class="c1"># FIXME inconsistent use of _size and size()</span>
    <span class="c1"># :attr: _size</span>
<div class="viewcode-block" id="LinearProbing._size">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._size">[documentos]</a>
    <span class="n">_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número de elementos (n) dentro de la tabla de hash, por defecto es 0 y se actualiza con cada operación que modifica la estructura.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># :attr: collisions</span>
<div class="viewcode-block" id="LinearProbing._collisions">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._collisions">[documentos]</a>
    <span class="n">_collisions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número de colisiones en la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO create a MAD class to handle the compression function?</span>
    <span class="c1"># private scale (a) factor for the mad compression function</span>
    <span class="c1"># :attr: _scale</span>
<div class="viewcode-block" id="LinearProbing._scale">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._scale">[documentos]</a>
    <span class="n">_scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número utilizado para calcular el código hash de la llave.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># private shift (b) factor for the mad compression function</span>
    <span class="c1"># :attr: _shift</span>
<div class="viewcode-block" id="LinearProbing._shift">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._shift">[documentos]</a>
    <span class="n">_shift</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número utilizado para calcular el código hash de la llave.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># current factor (alpha) for the working hash table</span>
    <span class="c1"># :attr: _cur_alpha</span>
<div class="viewcode-block" id="LinearProbing._cur_alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._cur_alpha">[documentos]</a>
    <span class="n">_cur_alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga actual de la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># maximum load factor (alpha) for the hash table</span>
    <span class="c1"># :attr: max_alpha</span>
<div class="viewcode-block" id="LinearProbing.max_alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.max_alpha">[documentos]</a>
    <span class="n">max_alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAX_PROBING_ALPHA</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga máximo de la tabla de hash, por defecto es 8.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># minimum load factor (alpha) for the hash table</span>
    <span class="c1"># :attr: min_alpha</span>
<div class="viewcode-block" id="LinearProbing.min_alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.min_alpha">[documentos]</a>
    <span class="n">min_alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">MIN_PROBING_ALPHA</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga mínimo de la tabla de hash, por defecto es 2.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the type of the entry values in the hash table</span>
    <span class="c1"># :attr: _value_type</span>
<div class="viewcode-block" id="LinearProbing._value_type">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._value_type">[documentos]</a>
    <span class="n">_value_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el tipo de dato de los valores en la entrada que contiene la tabla de hash, por defecto es *None* y se configura al cargar el primera entrada en el mapa.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the type of the entry keys in the hash table</span>
    <span class="c1"># :attr: _key_type</span>
<div class="viewcode-block" id="LinearProbing._key_type">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._key_type">[documentos]</a>
    <span class="n">_key_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el tipo de dato de las llaves en la entrada que contiene la tabla de hash, por defecto es *None* y se configura al cargar el primera entrada en el mapa.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the cmp_function is used to compare emtries, not defined by default</span>
    <span class="c1"># :attr: cmp_function</span>
<div class="viewcode-block" id="LinearProbing.cmp_function">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.cmp_function">[documentos]</a>
    <span class="n">cmp_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Función de comparación opcional que se utiliza para comparar los elementos del LinearProbing, por defecto es *None* y el *__post_init__()* configura la función por defecto *ht_default_cmp_funcion()*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the key is used to compare entries, not defined by default</span>
    <span class="c1"># :attr: key</span>
<div class="viewcode-block" id="LinearProbing.key">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.key">[documentos]</a>
    <span class="n">key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nombre de la llave opcional que se utiliza para comparar los elementos del LinearProbing, Por defecto es *None* y el *__post_init__()* configura la llave por defecto la llave *id* en *DEFAULT_DICT_KEY*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LinearProbing.__post_init__">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.__post_init__">[documentos]</a>
    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*__post_init__()* configura los valores por defecto de la estructura LinearProbing después de la inicialización de la misma. Configura los factores de carga (alpha), el número primo (P) para la función de compresión MAD, la capacidad (M) de la tabla de hash, la función de comparación y la llave para comparar los elementos del LinearProbing, y finalmente inicializa la tabla de hash con la capacidad (M) configurada.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO check if this is the best way make the initialization</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># setting capacity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nentries</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="c1"># setting scale and shift for MAD compression function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prime</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prime</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># setting the default compare function</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span> <span class="o">=</span> <span class="n">ht_default_cmp_funcion</span>
            <span class="c1"># setting the default key</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">DEFAULT_DICT_KEY</span>

            <span class="c1"># initializing the hash table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">(</span><span class="n">cmp_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span><span class="p">,</span>
                                        <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># bulding buckets in the hash table</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">:</span>
                <span class="c1"># adding an empty entry to the hash table</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="n">MapEntry</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># setting the current load factor</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span>

            <span class="c1"># TODO check if this is the best way to initialize the structure</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iodata</span><span class="p">,</span> <span class="n">VALID_IO_TYPE</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iodata</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iodata</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nentries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.default_cmp_function">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.default_cmp_function">[documentos]</a>
    <span class="k">def</span> <span class="nf">default_cmp_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key1</span><span class="p">,</span> <span class="n">entry2</span><span class="p">:</span> <span class="n">MapEntry</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*default_cmp_function()* procesa la llave existente en la entrada del LinearProbing y la compara con la llave del a entrada que se quiere agregar al LinearProbing.</span>
<span class="sd">        Args:</span>
<span class="sd">            key1 (Any): llave de la primera entrada a comparar.</span>
<span class="sd">            entry2 (MapEntry): segunda entrada (pareja llave-valor) a comparar.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: respuesta de la comparación entre los elementos, 0 si las llaves son iguales, 1 si key1 es mayor que la llave de entry2, -1 si key1 es menor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># passing self as the first argument to simulate a method</span>
            <span class="k">return</span> <span class="n">ht_default_cmp_funcion</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">entry2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing._handle_error">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._handle_error">[documentos]</a>
    <span class="k">def</span> <span class="nf">_handle_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">:</span> <span class="ne">Exception</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*_handle_error()* función privada que maneja los errores que se pueden presentar en el LinearProbing.</span>

<span class="sd">        Si se presenta un error en el LinearProbing, se formatea el error según el contexto (paquete/clase) y la función que lo generó, y lo reenvia al componente superior en la jerarquía de llamados para manejarlo segun sea considere conveniente.</span>

<span class="sd">        Args:</span>
<span class="sd">            err (Exception): Excepción que se generó en el LinearProbing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO check usability of this function</span>
        <span class="n">cur_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">cur_function</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
        <span class="n">error_handler</span><span class="p">(</span><span class="n">cur_context</span><span class="p">,</span> <span class="n">cur_function</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing._check_type">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._check_type">[documentos]</a>
    <span class="k">def</span> <span class="nf">_check_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*_check_type()* función privada que verifica que el tipo de dato de la entrada que se quiere agregar al LinearProbing sea del mismo tipo contenido dentro de los elementos del LinearProbing.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: error si el tipo de dato de la entrada que se quiere agregar no es el mismo que el tipo de dato de los elementos que ya contiene el LinearProbing.</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (T): entrada que se quiere procesar en LinearProbing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: operador que indica si el ADT LinearProbing es del mismo tipo que la entrada que se quiere procesar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO check usability of this function</span>
        <span class="c1"># if datastruct is empty, set the entry type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="c1"># self._data_type = type(entry)</span>
        <span class="c1"># check if the new entry is the same type as the other entries</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">()):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid key type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">())</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;for structure configured with type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">()):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid value type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;for structure configured with type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="c1"># otherwise, the type is valid</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="c1"># @property</span>
<div class="viewcode-block" id="LinearProbing.is_empty">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.is_empty">[documentos]</a>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*is_empty()* revisa si el LinearProbing está vacío.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: operador que indica si la estructura LinearProbing está vacía.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO change the method name to &quot;empty&quot; or @property &quot;empty&quot;?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


    <span class="c1"># @property</span>
<div class="viewcode-block" id="LinearProbing.size">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.size">[documentos]</a>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*size()* devuelve el numero de elementos que actualmente contiene el LinearProbing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: tamaño de la estructura LinearProbing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO change the method to @property &quot;size&quot;?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.contains">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.contains">[documentos]</a>
    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*contains()* responde si el LinearProbing contiene una entrada con la llave key.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave de la entrada (pareja llave-valor) que se quiere buscar en el LinearProbing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: operador que indica si el LinearProbing contiene o no una entrada con la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># assume the entry is not in the structure</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># use the MAD compression function to get the hash key</span>
            <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
            <span class="c1"># look for the entry in the hash table</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot</span><span class="p">(</span><span class="n">hkey</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># if the index of the entry is inside the hash table</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">found</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.put">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.put">[documentos]</a>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*put()* agrega una entrada (pareja llave-valor) al LinearProbing, si la llave ya existe en el LinearProbing, se reemplaza el valor.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada a la nueva entrada.</span>
<span class="sd">            value (T): el valor asociado a la nueva entrada.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: si el indice de la entrada en el mapa está fuera de los limites establecidos, se genera un error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># create a new entry for the entry</span>
            <span class="n">new_entry</span> <span class="o">=</span> <span class="n">MapEntry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_type</span><span class="p">(</span><span class="n">new_entry</span><span class="p">):</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># TODO do i need this?</span>
                <span class="k">if</span> <span class="n">hkey</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hkey</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">:</span>
                    <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The hash for the key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="n">err_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;is out of range fo capacity: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="c1"># check the entry availability in the hash table</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot</span><span class="p">(</span><span class="n">hkey</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">change_info</span><span class="p">(</span><span class="n">new_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="c1"># there is no space available in the hash table</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Space not available for key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># otherwise, the entry is not in the hash table, add it</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># get the entry of the hash table</span>
                    <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="c1"># if the entry hasnt been added, add it</span>
                    <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">add_element</span><span class="p">(</span><span class="n">new_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="c1"># otherwise, update the entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">change_info</span><span class="p">(</span><span class="n">new_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="c1"># check if there was a collision</span>
                    <span class="k">if</span> <span class="n">hkey</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_collisions</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># update the size of the hash table</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span>
                <span class="c1"># check if the structure needs to be rehashed</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rehash</span><span class="p">()</span>
            
            
            
            
            <span class="c1"># get the hash key for the entry</span>
            <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
            <span class="c1"># TODO do i need this?</span>
            <span class="k">if</span> <span class="n">hkey</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hkey</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The hash for the key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">err_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;is out of range fo capacity: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="c1"># check the entry availability in the hash table</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot</span><span class="p">(</span><span class="n">hkey</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">change_info</span><span class="p">(</span><span class="n">new_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="c1"># there is no space available in the hash table</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Space not available for key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># otherwise, the entry is not in the hash table, add it</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># get the entry of the hash table</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="c1"># if the entry hasnt been added, add it</span>
                <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">add_element</span><span class="p">(</span><span class="n">new_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="c1"># otherwise, update the entry</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">change_info</span><span class="p">(</span><span class="n">new_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="c1"># check if there was a collision</span>
                <span class="k">if</span> <span class="n">hkey</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_collisions</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># update the size of the hash table</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span>
            <span class="c1"># check if the structure needs to be rehashed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rehash</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.get">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.get">[documentos]</a>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*get()* devuelve la entrada (pareja llave-valor) cuya llave sea igual a key dentro del LinearProbing, si no existe una entrada con la llave key, devuelve None.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada a la entrada que se quiere buscar.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: error si la estructura está vacía.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[T]: entrada (pareja llave-valor) con la llave igual a key dentro del LinearProbing, None si no existe la entrada asociada a la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The structure is empty&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assume the entry is not in the structure</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># checking the entry index in the hash table</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot</span><span class="p">(</span><span class="n">hkey</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="c1"># if the entry is in the hashmap, return it</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">entry</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.check_bucket">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.check_bucket">[documentos]</a>
    <span class="k">def</span> <span class="nf">check_bucket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*check_bucket()* devuelve el bucket asociado a la llave key dentro del LinearProbing, si no existe una entrada con la llave key, devuelve None.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada al bucket que se quiere buscar.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: error si la estructura está vacía.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[T]: bucket asociado a la llave key dentro del LinearProbing, None si no existe la entrada asociada a la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The structure is empty&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assume the entry is not in the structure</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># checking the entry index in the hash table</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot</span><span class="p">(</span><span class="n">hkey</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="c1"># get the bucket according to the index</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">bucket</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.remove">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.remove">[documentos]</a>
    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*remove()* elimina la entrada (pareja llave-valor) cuya llave sea igual a key dentro del LinearProbing, si no existe una entrada con la llave key, devuelve None.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada a la entrada que se quiere eliminar.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: error si la estructura está vacía.</span>
<span class="sd">            Exception: error si la entrada que se quiere eliminar no existe dentro del bucket</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[T]: entrada (pareja llave-valor) que se eliminó del LinearProbing, None si no existe la entrada asociada a la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The structure is empty&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># finding the entry index in the hash table</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot</span><span class="p">(</span><span class="n">hkey</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="c1"># checking the bucket</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bucket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># gettting the entry from the hash table</span>
                        <span class="n">entry</span> <span class="o">=</span> <span class="n">bucket</span>
                        <span class="c1"># create a clean entry</span>
                        <span class="n">clean_entry</span> <span class="o">=</span> <span class="n">MapEntry</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="c1"># update the entry in the hash table</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">change_info</span><span class="p">(</span><span class="n">clean_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span>
                    <span class="c1"># TODO maybe i don&#39;t need this</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Entry for Key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_alpha</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rehash</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">entry</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.keys">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.keys">[documentos]</a>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*keys()* devuelve una lista (ArrayList) con todas las llaves de las entradas (parejas llave-valor) del LinearProbing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ArrayList[T]: lista (ArrayList) con todas las llaves del LinearProbing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">keys_lt</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                        <span class="n">keys_lt</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">keys_lt</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.values">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.values">[documentos]</a>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*values()* devuelve una lista (ArrayList) con todos los valores de las entradas (parejas llave-valor) del LinearProbing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ArrayList[T]: lista (ArrayList) con todos los valores del LinearProbing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">values_lt</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                        <span class="n">values_lt</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">values_lt</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.entries">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.entries">[documentos]</a>
    <span class="k">def</span> <span class="nf">entries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*entries()* devuelve una lista (ArrayList) con todas las entradas (parejas llave-valor) del LinearProbing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ArrayList[T]: lista (ArrayList) con todas las entradas del LinearProbing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">items_lt</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">(),</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                        <span class="n">items_lt</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">items_lt</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing._find_slot">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._find_slot">[documentos]</a>
    <span class="k">def</span> <span class="nf">_find_slot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hkey</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_find_slot _summary_</span>

<span class="sd">        Args:</span>
<span class="sd">            hkey (int): _description_</span>
<span class="sd">            key (T): _description_</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO add docstring</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># assume we don&#39;t find the entry</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inputs:&quot;</span><span class="p">,</span> <span class="n">hkey</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># sets a limit for the number of probes</span>
            <span class="n">max_probing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
            <span class="c1"># sets the initial search index</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># i = </span>
            <span class="c1"># setting the found flag</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># setting the number of probes</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># look for the correct entry in the hash table</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;max_probing:&quot;</span><span class="p">,</span> <span class="n">max_probing</span><span class="p">)</span>

            <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;</span> <span class="n">max_probing</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">hkey</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_available</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">cp</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;idx: </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">, cp: </span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">findSlot</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">hkey_t</span><span class="p">,</span> <span class="n">cmpfunction</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Encuentra una posición libre en la tabla de hash.</span>
<span class="sd">            map: la tabla de hash</span>
<span class="sd">            key: la llave</span>
<span class="sd">            hkey_t: La posición inicial de la llave</span>
<span class="sd">            cmpfunction: funcion de comparación para la búsqueda de la llave</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">avail_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>          <span class="c1"># no se ha encontrado una posición aun</span>
                <span class="n">si</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">table</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">si</span> <span class="o">!=</span> <span class="n">hkey_t</span><span class="p">):</span>  <span class="c1"># Se busca una posición</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">si</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">si</span> <span class="o">=</span> <span class="n">hkey_t</span>
                    <span class="k">if</span> <span class="n">isAvailable</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">si</span><span class="p">):</span>  <span class="c1"># La posición esta disponible</span>
                        <span class="n">entry_elm</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">getElement</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">avail_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">avail_idx</span> <span class="o">=</span> <span class="n">si</span>            <span class="c1"># primera posición disponible</span>
                        <span class="k">if</span> <span class="n">entry_elm</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>       <span class="c1"># nunca ha sido utilizada</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>                    <span class="c1"># la posicion no estaba disponible</span>
                        <span class="n">entry_elm</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">getElement</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">cmpfunction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">entry_elm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Es la llave</span>
                            <span class="k">return</span> <span class="n">si</span>               <span class="c1"># Se  retorna la posicion</span>
                    <span class="n">si</span> <span class="o">=</span> <span class="p">(((</span><span class="n">si</span><span class="p">)</span> <span class="o">%</span> <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;capacity&#39;</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">avail_idx</span><span class="p">)</span>    <span class="c1"># numero negativo indica que el elemento no estaba</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exp</span><span class="p">:</span>
                <span class="c1"># FIXME Ajustar mensaje de error para que sea más claro</span>
                <span class="n">error</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="s1">&#39;Probe:findslot&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="LinearProbing.findSlot2">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.findSlot2">[documentos]</a>
    <span class="k">def</span> <span class="nf">findSlot2</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">hashvalue</span><span class="p">,</span> <span class="n">cmpfunction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encuentra una posición libre en la tabla de hash.</span>
<span class="sd">        map: la tabla de hash</span>
<span class="sd">        key: la llave</span>
<span class="sd">        hashvalue: La posición inicial de la llave</span>
<span class="sd">        cmpfunction: funcion de comparación para la búsqueda de la llave</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">avail</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>          <span class="c1"># no se ha encontrado una posición aun</span>
            <span class="n">searchpos</span> <span class="o">=</span> <span class="n">hashvalue</span>
            <span class="n">table</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>       <span class="c1"># flag to indicate if a position has been found</span>

            <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>  <span class="c1"># Se busca una posición</span>
                <span class="k">if</span> <span class="n">isAvailable</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">searchpos</span><span class="p">):</span>  <span class="c1"># La posición esta disponible</span>
                    <span class="n">element</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">getElement</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">searchpos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">avail</span> <span class="o">=</span> <span class="n">searchpos</span>            <span class="c1"># primera posición disponible</span>
                    <span class="k">if</span> <span class="n">element</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>       <span class="c1"># nunca ha sido utilizada</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>                    <span class="c1"># la posicion no estaba disponible</span>
                    <span class="n">element</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">getElement</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">searchpos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cmpfunction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Es la llave</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                    <span class="n">searchpos</span> <span class="o">=</span> <span class="p">(((</span><span class="n">searchpos</span><span class="p">)</span> <span class="o">%</span> <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;capacity&#39;</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">searchpos</span> <span class="o">==</span> <span class="n">hashvalue</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># numero negativo indica que el elemento no estaba</span>
            <span class="k">return</span> <span class="n">searchpos</span> <span class="k">if</span> <span class="n">found</span> <span class="k">else</span> <span class="o">-</span><span class="p">(</span><span class="n">avail</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exp</span><span class="p">:</span>
            <span class="c1"># FIXME Ajustar mensaje de error para que sea más claro</span>
            <span class="n">error</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="s1">&#39;Probe:findslot&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing.findSlot3">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.findSlot3">[documentos]</a>
    <span class="k">def</span> <span class="nf">findSlot3</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">hashvalue</span><span class="p">,</span> <span class="n">cmpfunction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encuentra una posición libre en la tabla de hash.</span>
<span class="sd">        map: la tabla de hash</span>
<span class="sd">        key: la llave</span>
<span class="sd">        hashvalue: La posición inicial de la llave</span>
<span class="sd">        cmpfunction: funcion de comparación para la búsqueda de la llave</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">avail</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>          <span class="c1"># no se ha encontrado una posición aun</span>
            <span class="n">searchpos</span> <span class="o">=</span> <span class="n">hashvalue</span>
            <span class="n">table</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span>
            <span class="n">probe_count</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c1"># count the number of probes</span>

            <span class="c1"># Se busca una posición</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">searchpos</span> <span class="o">!=</span> <span class="n">hashvalue</span> <span class="ow">or</span> <span class="n">probe_count</span> <span class="o">&lt;</span> <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;capacity&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">isAvailable</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">searchpos</span><span class="p">):</span>  <span class="c1"># La posición esta disponible</span>
                    <span class="n">element</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">getElement</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">searchpos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">avail</span> <span class="o">=</span> <span class="n">searchpos</span>            <span class="c1"># primera posición disponible</span>
                    <span class="k">if</span> <span class="n">element</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>       <span class="c1"># nunca ha sido utilizada</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>                    <span class="c1"># la posicion no estaba disponible</span>
                    <span class="n">element</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">getElement</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">searchpos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cmpfunction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Es la llave</span>
                        <span class="n">avail</span> <span class="o">=</span> <span class="n">searchpos</span>               <span class="c1"># Se  guarda la posicion</span>
                        <span class="k">break</span>
                <span class="n">searchpos</span> <span class="o">=</span> <span class="p">(((</span><span class="n">searchpos</span><span class="p">)</span> <span class="o">%</span> <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;capacity&#39;</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">probe_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># increment the probe count</span>

            <span class="c1"># numero negativo indica que el elemento no estaba</span>
            <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">avail</span><span class="p">)</span> <span class="k">if</span> <span class="n">avail</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">avail</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exp</span><span class="p">:</span>
            <span class="c1"># FIXME Ajustar mensaje de error para que sea más claro</span>
            <span class="n">error</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="s1">&#39;Probe:findslot&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearProbing._is_available">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing._is_available">[documentos]</a>
    <span class="k">def</span> <span class="nf">_is_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_is_available _summary_</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (int): _description_</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO add docstring</span>
        <span class="c1"># assume the slot is unavailable</span>
        <span class="n">available</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># get the entry from the map</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1"># check the entry availability</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">EMPTY</span><span class="p">):</span>
            <span class="n">available</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># return the availability of the slot</span>
        <span class="k">return</span> <span class="n">available</span></div>


<div class="viewcode-block" id="LinearProbing.rehash">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/probinghashtable/index.html#DISClib.DataStructures.LinearProbing.rehash">[documentos]</a>
    <span class="k">def</span> <span class="nf">rehash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*rehash()* reconstruye la tabla de hash con una nueva capacidad (M) y un nuevo factor de carga (alpha) según los límites establecidos por el usuario en los atributos *max_alpha* y *min_alpha*.</span>

<span class="sd">        Si el factor de carga (alpha) es mayor que el límite superior (max_alpha), se duplica la capacidad (M) buscando el siguiente número primo y se reconstruye la tabla de hash.</span>

<span class="sd">        Si el factor de carga (alpha) es menor que el límite inferior (min_alpha), se reduce a la mitad la capacidad (M) de la tabla de hash buscando el siguiente número primo y se reconstruye la tabla de hash.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># check if the structure is rehashable</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rehashable</span><span class="p">:</span>
                <span class="c1"># find the new capacity according to limits</span>
                <span class="c1"># augmenting the capacity</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">:</span>
                    <span class="n">new_capacity</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="c1"># reducing the capacity</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_alpha</span><span class="p">:</span>
                    <span class="n">new_capacity</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># asigning the new capacity</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">=</span> <span class="n">new_capacity</span>

                <span class="c1"># reseting the size, collisions and current load factor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collisions</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># creating the new hash table</span>
                <span class="n">new_table</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">(</span><span class="n">cmp_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span><span class="p">,</span>
                                      <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="c1"># keep in memory the old hash table</span>
                <span class="n">old_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span>

                <span class="c1"># Create new table with empty buckets</span>
                <span class="n">new_table</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">([</span><span class="n">MapEntry</span><span class="p">()</span>
                                       <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)])</span>

                <span class="c1"># replace the old table with the new one</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span> <span class="o">=</span> <span class="n">new_table</span>

                <span class="c1"># iterate over the old table</span>
                <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">old_table</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">()</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
                            <span class="c1"># print(key, value)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Derechos de autor Uniandes, Bogotá - Colombia, Sur América,
             Facultad de Ingeniería, DISC Desarrollado
             para ISIS-1225, EDA.</p>
  </div>

  Compilado con <a href="https://www.sphinx-doc.org/">Sphinx</a> usando un
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">tema</a>
    proporcionado por <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>