<!DOCTYPE html>
<html class="writer-html5" lang="es" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DISClib.DataStructures.chaininghashtable &mdash; documentación de DISClib - 0.0.1</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/fonts.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=6fcc102b"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../../_static/translations.js?v=efdbd0b9"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DISClib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Buscar documentos" aria-label="Buscar documentos" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">DISClib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../testmd.html">Example Markdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DISClib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Código de módulo</a></li>
          <li class="breadcrumb-item"><a href="../../DISClib.html">DISClib</a></li>
          <li class="breadcrumb-item"><a href="../DataStructures.html">DISClib.DataStructures</a></li>
      <li class="breadcrumb-item active">DISClib.DataStructures.chaininghashtable</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Código fuente para DISClib.DataStructures.chaininghashtable</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Este ADT representa una tabla de hash con el método de encadenamiento por de separación (Separate Chaining). Donde la llave es única para cada valor y el valor puede ser cualquier tipo de dato.</span>

<span class="sd">Ademas, contiene la estructura **Bucket** basada en una lista sencillamente enlazada (SingleLinked) donde se almacenan las entradas (parejas llave-valor) que sufren colisiones en la tabla de hash.</span>

<span class="sd">*IMPORTANTE:* Este código y sus especificaciones para Python están basados en las implementaciones propuestas por los siguientes autores/libros:</span>

<span class="sd">    #. Algorithms, 4th Edition, Robert Sedgewick y Kevin Wayne.</span>
<span class="sd">    #. Data Structure and Algorithms in Python, M.T. Goodrich, R. Tamassia, M.H. Goldwasser.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># native python modules</span>
<span class="c1"># import dataclass to define the hash table</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="c1"># import modules for defining the entries type in the hash table</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Generic</span>
<span class="c1"># import inspect for getting the name of the current function</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="c1"># random module for the MAD compression function</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="c1"># custom modules</span>
<span class="c1"># generic error handling and type checking</span>
<span class="kn">from</span> <span class="nn">DISClib.DataStructures.mapentry</span> <span class="kn">import</span> <span class="n">MapEntry</span>
<span class="kn">from</span> <span class="nn">DISClib.DataStructures.arraylist</span> <span class="kn">import</span> <span class="n">ArrayList</span>
<span class="kn">from</span> <span class="nn">DISClib.DataStructures.singlelinkedlist</span> <span class="kn">import</span> <span class="n">SingleLinked</span>
<span class="c1"># util functions for the hash table</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.numbers</span> <span class="kn">import</span> <span class="n">next_prime</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.numbers</span> <span class="kn">import</span> <span class="n">hash_compress</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.error</span> <span class="kn">import</span> <span class="n">error_handler</span>
<span class="c1"># default cmp function for the hash table</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">ht_default_cmp_funcion</span>
<span class="c1"># default data type for the hash table</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">T</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">VALID_DATA_TYPE_LT</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">DEFAULT_DICT_KEY</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">VALID_IO_TYPE</span>
<span class="kn">from</span> <span class="nn">DISClib.Utils.default</span> <span class="kn">import</span> <span class="n">DEFAULT_PRIME</span>


<span class="c1"># checking custom modules</span>
<span class="k">assert</span> <span class="n">MapEntry</span>
<span class="k">assert</span> <span class="n">ArrayList</span>
<span class="k">assert</span> <span class="n">SingleLinked</span>
<span class="k">assert</span> <span class="n">next_prime</span>
<span class="k">assert</span> <span class="n">hash_compress</span>
<span class="k">assert</span> <span class="n">error_handler</span>
<span class="k">assert</span> <span class="n">ht_default_cmp_funcion</span>
<span class="k">assert</span> <span class="n">T</span>
<span class="k">assert</span> <span class="n">VALID_DATA_TYPE_LT</span>
<span class="k">assert</span> <span class="n">DEFAULT_DICT_KEY</span>
<span class="k">assert</span> <span class="n">VALID_IO_TYPE</span>
<span class="k">assert</span> <span class="n">DEFAULT_PRIME</span>

<span class="c1"># default load factor for separating chaining</span>
<span class="c1"># :data: DEFAULT_CHAINING_ALPHA</span>
<div class="viewcode-block" id="DEFAULT_CHAINING_ALPHA">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.DEFAULT_CHAINING_ALPHA">[documentos]</a>
<span class="n">DEFAULT_CHAINING_ALPHA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.0</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor de carga (alpha) por defecto e ideal para el SeparateChaining, por defecto es 4.0.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># :data: MAX_CHAINING_ALPHA</span>
<div class="viewcode-block" id="MAX_CHAINING_ALPHA">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.MAX_CHAINING_ALPHA">[documentos]</a>
<span class="n">MAX_CHAINING_ALPHA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">8.0</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor de carga (alpha) máximo para el SeparateChaining, por defecto es 8.0.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># :data: MIN_CHAINING_ALPHA</span>
<div class="viewcode-block" id="MIN_CHAINING_ALPHA">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.MIN_CHAINING_ALPHA">[documentos]</a>
<span class="n">MIN_CHAINING_ALPHA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor de carga (alpha) mínimo para el SeparateChaining, por defecto es 2.0.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="nd">@dataclass</span>
<div class="viewcode-block" id="Bucket">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.Bucket">[documentos]</a>
<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">SingleLinked</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;**Bucket** Clase que representa un bucket de una tabla de hash. Esta clase hereda de la clase SingleLinked de DISCLib para representar un bucket de una tabla de hash con el método de encadenamiento por separación (Separate Chaining).</span>

<span class="sd">    Args:</span>
<span class="sd">        SingleLinked (T): Lista sencillamente encadenada que representa un bucket de una tabla de hash con el método de encadenamiento por separación (Separate Chaining).</span>
<span class="sd">        Generic (T): TAD (Tipo Abstracto de Datos) o ADT (Abstract Data Type) para representar una estructura de datos genérica en python.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the same as ..</span>
    <span class="k">pass</span></div>



<span class="nd">@dataclass</span>
<div class="viewcode-block" id="SeparateChaining">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining">[documentos]</a>
<span class="k">class</span> <span class="nc">SeparateChaining</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;**SeparateChaining** Es una clase que representa una tabla de hash con el método de encadenamiento por de separación (Separate Chaining). Donde la llave es única para cada valor y el valor puede ser cualquier tipo de dato.</span>

<span class="sd">    Args:</span>
<span class="sd">        Generic (T): Tipo de dato genérico dentro del registro del mapa.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: error si la información del registro del mapa (llave o valor) no son del tipo adecuado.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SeparateChaining: ADT de tipo SeparateChaining o tabla de hash con separación por encadenamiento.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># input tuples from python list</span>
    <span class="c1"># :attr: iodata</span>
<div class="viewcode-block" id="SeparateChaining.iodata">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.iodata">[documentos]</a>
    <span class="n">iodata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lista nativa de Python que contiene los elementos de entrada a la estructura, por defecto es None y el usuario puede incluir una lista nativa de python como argumento.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># boolean to indicate if the hash table can be rehashed</span>
    <span class="c1"># :attr: rehashable</span>
<div class="viewcode-block" id="SeparateChaining.rehashable">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.rehashable">[documentos]</a>
    <span class="n">rehashable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es un booleano que indica si la tabla de hash se puede reconstruir utilizando el método de rehash, por defecto es True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># reserved space for the hash table</span>
    <span class="c1"># :attr: nentries</span>
<div class="viewcode-block" id="SeparateChaining.nentries">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.nentries">[documentos]</a>
    <span class="n">nentries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el espacio inicial reservado para la tabla de hash (n), por defecto es 1, pero debe configurarse según el número de entradas que se espera almacenar.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># starting capacity (M|m) for the hash table</span>
    <span class="c1"># :attr: mcapacity</span>
<div class="viewcode-block" id="SeparateChaining.mcapacity">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.mcapacity">[documentos]</a>
    <span class="n">mcapacity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es la capacidad (M) con la que se inicializa la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># starting load factor (alpha) for the hash table</span>
    <span class="c1"># :attr: alpha</span>
<div class="viewcode-block" id="SeparateChaining.alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.alpha">[documentos]</a>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_CHAINING_ALPHA</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga (alpha) con el que se inicializa la tabla de hash, por defecto es 4.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the cmp_function is used to compare emtries, not defined by default</span>
    <span class="c1"># :attr: cmp_function</span>
<div class="viewcode-block" id="SeparateChaining.cmp_function">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.cmp_function">[documentos]</a>
    <span class="n">cmp_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Función de comparación opcional que se utiliza para comparar los elementos del SeparateChaining, por defecto es *None* y el *__post_init__()* configura la función por defecto *ht_default_cmp_funcion()*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># actual place to store the entries in the hash table</span>
    <span class="c1"># :attr: hash_table</span>
<div class="viewcode-block" id="SeparateChaining.hash_table">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.hash_table">[documentos]</a>
    <span class="n">hash_table</span><span class="p">:</span> <span class="n">ArrayList</span><span class="p">[</span><span class="n">Bucket</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">ArrayList</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el indice de la tabla de hash donde se almacenan los *Buckets*, implementado con un *ArrayList* de DISCLib. en el *__post_init__()* se inicializa con la capacidad inicial de la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the key is used to compare entries, not defined by default</span>
    <span class="c1"># :attr: key</span>
<div class="viewcode-block" id="SeparateChaining.key">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.key">[documentos]</a>
    <span class="n">key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_DICT_KEY</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nombre de la llave opcional que se utiliza para comparar los elementos del SeparateChaining, Por defecto la llave es la cadena de caracteres *&quot;id&quot;* definida en *DEFAULT_DICT_KEY*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prime number (P) for the MAD compression function</span>
    <span class="c1"># :attr: prime</span>
<div class="viewcode-block" id="SeparateChaining.prime">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.prime">[documentos]</a>
    <span class="n">prime</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_PRIME</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número primo (P) utilizado para calcular el código hash de la llave con la función de compresión MAD, por defecto es 109345121 definido en *DEFAULT_PRIME*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO create a MAD class to handle the compression function?</span>
    <span class="c1"># private scale (a) factor for the mad compression function</span>
    <span class="c1"># :attr: _scale</span>
<div class="viewcode-block" id="SeparateChaining._scale">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._scale">[documentos]</a>
    <span class="n">_scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número utilizado para calcular el código hash de la llave.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># private shift (b) factor for the mad compression function</span>
    <span class="c1"># :attr: _shift</span>
<div class="viewcode-block" id="SeparateChaining._shift">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._shift">[documentos]</a>
    <span class="n">_shift</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número utilizado para calcular el código hash de la llave.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># current factor (alpha) for the working hash table</span>
    <span class="c1"># :attr: _cur_alpha</span>
<div class="viewcode-block" id="SeparateChaining._cur_alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._cur_alpha">[documentos]</a>
    <span class="n">_cur_alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga actual de la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># minimum load factor (alpha) for the hash table</span>
    <span class="c1"># :attr: min_alpha</span>
<div class="viewcode-block" id="SeparateChaining.min_alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.min_alpha">[documentos]</a>
    <span class="n">min_alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">MIN_CHAINING_ALPHA</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga mínimo de la tabla de hash, por defecto es 2.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># maximum load factor (alpha) for the hash table</span>
    <span class="c1"># :attr: max_alpha</span>
<div class="viewcode-block" id="SeparateChaining.max_alpha">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.max_alpha">[documentos]</a>
    <span class="n">max_alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAX_CHAINING_ALPHA</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el factor de carga máximo de la tabla de hash, por defecto es 8.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># actual number of used entries (n) in the hash table</span>
    <span class="c1"># FIXME inconsistent use of _size and size()</span>
    <span class="c1"># :attr: _size</span>
<div class="viewcode-block" id="SeparateChaining._size">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._size">[documentos]</a>
    <span class="n">_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número de elementos (n) dentro de la tabla de hash, por defecto es 0 y se actualiza con cada operación que modifica la estructura.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># :attr: collisions</span>
<div class="viewcode-block" id="SeparateChaining._collisions">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._collisions">[documentos]</a>
    <span class="n">_collisions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el número de colisiones en la tabla de hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the type of the entry keys in the hash table</span>
    <span class="c1"># :attr: _key_type</span>
<div class="viewcode-block" id="SeparateChaining._key_type">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._key_type">[documentos]</a>
    <span class="n">_key_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el tipo de dato de las llaves en la entrada que contiene la tabla de hash, por defecto es *None* y se configura al cargar el primera entrada en el mapa.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the type of the entry values in the hash table</span>
    <span class="c1"># :attr: _value_type</span>
<div class="viewcode-block" id="SeparateChaining._value_type">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/chaininghashtable/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._value_type">[documentos]</a>
    <span class="n">_value_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Es el tipo de dato de los valores en la entrada que contiene la tabla de hash, por defecto es *None* y se configura al cargar el primera entrada en el mapa.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SeparateChaining.__post_init__">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.__post_init__">[documentos]</a>
    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*__post_init__()* configura los valores por defecto de la estructura SeparateChaining después de la inicialización de la misma. Configura los factores de carga (alpha), el número primo (P) para la función de compresión MAD, la capacidad (M) de la tabla de hash, la función de comparación y la llave para comparar los elementos del SeparateChaining, y finalmente inicializa la tabla de hash con la capacidad (M) configurada.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO check if this is the best way make the initialization</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># setting capacity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nentries</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="c1"># setting scale and shift for MAD compression function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prime</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prime</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># setting the default compare function</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_cmp_function</span>

            <span class="c1"># initializing new hash table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">(</span><span class="n">cmp_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span><span class="p">,</span>
                                        <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># bulding buckets in the hash table</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">:</span>
                <span class="c1"># bucket is a SingleLinked list</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="n">Bucket</span><span class="p">(</span><span class="n">cmp_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span><span class="p">,</span>
                                <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="c1"># add the bucket to the hash table</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># setting the current load factor</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span>

            <span class="c1"># TODO is the best way to create the structure???</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iodata</span><span class="p">,</span> <span class="n">VALID_IO_TYPE</span><span class="p">):</span>
                <span class="c1"># get the type of the data in the list</span>
                <span class="c1"># if is a dict, use the key type</span>
                <span class="c1"># print(type(self.iodata), self.iodata)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iodata</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iodata</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
                <span class="c1"># otherwise, manage as data list</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iodata</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iodata</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># # fix discrepancies between the size and the number of entries (n)</span>
            <span class="c1"># if self._size != self.nentries:</span>
            <span class="c1">#     self.nentries = self._size</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.default_cmp_function">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.default_cmp_function">[documentos]</a>
    <span class="k">def</span> <span class="nf">default_cmp_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key1</span><span class="p">,</span> <span class="n">entry2</span><span class="p">:</span> <span class="n">MapEntry</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*default_cmp_function()* procesa la llave existente en la entrada del SeparateChaining y la compara con la llave del a entrada que se quiere agregar al SeparateChaining.</span>
<span class="sd">        Args:</span>
<span class="sd">            key1 (Any): llave de la primera entrada a comparar.</span>
<span class="sd">            entry2 (MapEntry): segunda entrada (pareja llave-valor) a comparar.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: respuesta de la comparación entre los elementos, 0 si las llaves son iguales, 1 si key1 es mayor que la llave de entry2, -1 si key1 es menor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># using the default compare function for the key</span>
            <span class="k">return</span> <span class="n">ht_default_cmp_funcion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">key1</span><span class="p">,</span> <span class="n">entry2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining._handle_error">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._handle_error">[documentos]</a>
    <span class="k">def</span> <span class="nf">_handle_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">:</span> <span class="ne">Exception</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*_handle_error()* función privada que maneja los errores que se pueden presentar en el SeparateChaining.</span>

<span class="sd">        Si se presenta un error en el SeparateChaining, se formatea el error según el contexto (paquete/clase) y la función que lo generó, y lo reenvia al componente superior en la jerarquía de llamados para manejarlo segun sea considere conveniente.</span>

<span class="sd">        Args:</span>
<span class="sd">            err (Exception): Excepción que se generó en el SeparateChaining.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO check usability of this function</span>
        <span class="n">cur_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">cur_function</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
        <span class="n">error_handler</span><span class="p">(</span><span class="n">cur_context</span><span class="p">,</span> <span class="n">cur_function</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining._check_type">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining._check_type">[documentos]</a>
    <span class="k">def</span> <span class="nf">_check_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">:</span> <span class="n">MapEntry</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*_check_type()* función privada que verifica que el tipo de dato de la entrada que se quiere agregar al SeparateChaining sea del mismo tipo contenido dentro de los elementos del SeparateChaining.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: error si el tipo de dato de la entrada que se quiere agregar no es el mismo que el tipo de dato de los elementos que ya contiene el SeparateChaining.</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (T): entrada (pareja llave-valor) que se quiere procesar en SeparateChaining.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: operador que indica si el ADT SeparateChaining es del mismo tipo que el entrada que se quiere procesar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO check usability of this function</span>
        <span class="c1"># if datastruct is empty, set the entry type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="c1"># self._data_type = type(entry)</span>
        <span class="c1"># check if the new entry is the same type as the other entries</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">()):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid key type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">())</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;for structure configured with type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">()):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid value type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;for structure configured with type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="c1"># otherwise, the type is valid</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="c1"># @property</span>
<div class="viewcode-block" id="SeparateChaining.is_empty">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.is_empty">[documentos]</a>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*is_empty()* revisa si el SeparateChaining está vacío.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: operador que indica si la estructura SeparateChaining está vacía.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO change the method name to &quot;empty&quot; or @property &quot;empty&quot;?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


    <span class="c1"># @property</span>
<div class="viewcode-block" id="SeparateChaining.size">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.size">[documentos]</a>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*size()* devuelve el numero de elementos que actualmente contiene el SeparateChaining.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: tamaño de la estructura SeparateChaining.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO change the method to @property &quot;size&quot;?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.contains">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.contains">[documentos]</a>
    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*contains()* responde si el SeparateChaining contiene una entrada con la llave key.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave de la entrada (pareja llave-valor) que se quiere buscar en el SeparateChaining.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: operador que indica si el SeparateChaining contiene o no una entrada con la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># assume the entry is not in the structure</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># use the MAD compression function to get the hash key</span>
            <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
            <span class="c1"># look into the bucket</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">hkey</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># if the entry is in the bucket, return True</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">found</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.put">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.put">[documentos]</a>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*put()* agrega una entrada (pareja llave-valor) al SeparateChaining, si la llave ya existe en el SeparateChaining, se reemplaza el valor.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada a la nueva entrada.</span>
<span class="sd">            value (T): el valor asociado a la nueva entrada.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: si el indice de la entrada en el mapa está fuera de los limites establecidos, se genera un error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># create a new entry for the entry</span>
            <span class="n">new_entry</span> <span class="o">=</span> <span class="n">MapEntry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># cheking the type of the entry</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_type</span><span class="p">(</span><span class="n">new_entry</span><span class="p">):</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># TODO do i need this?</span>
                <span class="k">if</span> <span class="n">hkey</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hkey</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">:</span>
                    <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The hash for the key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="n">err_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;is out of range fo capacity: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="c1"># checking the bucket</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">hkey</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="c1"># the entry is not in the bucket, add it and a collision</span>
                <span class="c1"># the entry is in the bucket, update it</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">bucket</span><span class="o">.</span><span class="n">change_info</span><span class="p">(</span><span class="n">new_entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="c1"># otherwise, is a new entry</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_collisions</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">bucket</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">new_entry</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span>
                <span class="c1"># check if the structure needs to be rehashed</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rehash</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.get">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.get">[documentos]</a>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*get()* devuelve la entrada (pareja llave-valor) cuya llave sea igual a key dentro del SeparateChaining, si no existe una entrada con la llave key, devuelve None.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada a la entrada que se quiere buscar.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: error si la estructura está vacía.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[T]: entrada (pareja llave-valor) con la llave igual a key dentro del SeparateChaining, None si no existe la entrada asociada a la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The structure is empty&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assume the entry is not in the structure</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># checking the bucket</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">hkey</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="c1"># if the entry is in the bucket, return it</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">entry</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">entry</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.check_bucket">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.check_bucket">[documentos]</a>
    <span class="k">def</span> <span class="nf">check_bucket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*check_bucket()* devuelve el bucket asociado a la llave key dentro del SeparateChaining, si no existe una entrada con la llave key, devuelve None.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada al bucket que se quiere buscar.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: error si la estructura está vacía.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[T]: bucket asociado a la llave key dentro del SeparateChaining, None si no existe la entrada asociada a la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The structure is empty&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assume the entry is not in the structure</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># checking the bucket</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">hkey</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">bucket</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.remove">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.remove">[documentos]</a>
    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*remove()* elimina la entrada (pareja llave-valor) cuya llave sea igual a key dentro del SeparateChaining, si no existe una entrada con la llave key, devuelve None.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (T): llave asociada a la entrada que se quiere eliminar.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: error si la estructura está vacía.</span>
<span class="sd">            Exception: error si la entrada que se quiere eliminar no existe dentro del bucket</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[T]: entrada (pareja llave-valor) que se eliminó del SeparateChaining, None si no existe la entrada asociada a la llave key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The structure is empty&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># get the hash key for the entry</span>
                <span class="n">hkey</span> <span class="o">=</span> <span class="n">hash_compress</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">)</span>
                <span class="c1"># checking the bucket</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="n">hkey</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">entry</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="n">remove_element</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span>
                    <span class="c1"># TODO maybe i don&#39;t need this</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Entry for Key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_alpha</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rehash</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">entry</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.keys">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.keys">[documentos]</a>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SingleLinked</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*keys()* devuelve una lista (SingleLinked) con todas las llaves de las entradas (parejas llave-valor) del SeparateChaining.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SingleLinked[T]: lista (ArrSingleLinkedayList) con todas las llaves del SeparateChaining.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">keys_lt</span> <span class="o">=</span> <span class="n">SingleLinked</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># FIXME improve with SingleLinked concat() method?</span>
            <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                        <span class="n">keys_lt</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">keys_lt</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.values">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.values">[documentos]</a>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SingleLinked</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*values()* devuelve una lista (SingleLinked) con todos los valores de las entradas (parejas llave-valor) del SeparateChaining.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SingleLinked[T]: lista (SingleLinked) con todos los valores del SeparateChaining.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">values_lt</span> <span class="o">=</span> <span class="n">SingleLinked</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># FIXME improve with SingleLinked concat() method?</span>
            <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                        <span class="n">values_lt</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">values_lt</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.entries">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.entries">[documentos]</a>
    <span class="k">def</span> <span class="nf">entries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SingleLinked</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*entries()* devuelve una lista (SingleLinked) con todas las entradas (parejas llave-valor) del SeparateChaining.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SingleLinked[T]: lista (SingleLinked) con todas las entradas del SeparateChaining.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">entries_lt</span> <span class="o">=</span> <span class="n">SingleLinked</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># FIXME improve with SingleLinked concat() method?</span>
            <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">(),</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                        <span class="n">entries_lt</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">entries_lt</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateChaining.rehash">
<a class="viewcode-back" href="../../../autoapi/DISClib/DataStructures/index.html#DISClib.DataStructures.chaininghashtable.SeparateChaining.rehash">[documentos]</a>
    <span class="k">def</span> <span class="nf">rehash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;*rehash()* reconstruye la tabla de hash con una nueva capacidad (M) y un nuevo factor de carga (alpha) según los límites establecidos por el usuario en los atributos *max_alpha* y *min_alpha*.</span>

<span class="sd">        Si el factor de carga (alpha) es mayor que el límite superior (max_alpha), se duplica la capacidad (M) buscando el siguiente número primo y se reconstruye la tabla de hash.</span>

<span class="sd">        Si el factor de carga (alpha) es menor que el límite inferior (min_alpha), se reduce a la mitad la capacidad (M) de la tabla de hash buscando el siguiente número primo y se reconstruye la tabla de hash.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># check if the structure is rehashable</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rehashable</span><span class="p">:</span>
                <span class="c1"># find the new capacity according to limits</span>
                <span class="c1"># augmenting the capacity</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">:</span>
                    <span class="n">new_capacity</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="c1"># reducing the capacity</span>
                <span class="c1"># TODO check if the reduced capacity is a good fit</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_alpha</span><span class="p">:</span>
                    <span class="n">new_capacity</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># asigning the new capacity</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span> <span class="o">=</span> <span class="n">new_capacity</span>

                <span class="c1"># reseting the size, collisions and current load factor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collisions</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cur_alpha</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># creating the new hash table</span>
                <span class="n">new_table</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="p">(</span><span class="n">cmp_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span><span class="p">,</span>
                                      <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="c1"># keep in memory the old hash table</span>
                <span class="n">old_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span>

                <span class="c1"># Create the empty buckets in thenew hash table</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcapacity</span><span class="p">:</span>
                    <span class="c1"># bucket is a SingleLinked list</span>
                    <span class="n">bucket</span> <span class="o">=</span> <span class="n">Bucket</span><span class="p">(</span><span class="n">cmp_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cmp_function</span><span class="p">,</span>
                                    <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">new_table</span><span class="o">.</span><span class="n">add_last</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># replace the old table with the new one</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hash_table</span> <span class="o">=</span> <span class="n">new_table</span>

                <span class="c1"># iterate over the old table</span>
                <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">old_table</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_key</span><span class="p">()</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Derechos de autor Uniandes, Bogotá - Colombia, Sur América,
             Facultad de Ingeniería, DISC Desarrollado
             para ISIS-1225, EDA.</p>
  </div>

  Compilado con <a href="https://www.sphinx-doc.org/">Sphinx</a> usando un
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">tema</a>
    proporcionado por <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>